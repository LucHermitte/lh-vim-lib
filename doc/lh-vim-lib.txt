*lh-vim-lib.txt*        Vim common libraries (v5.3.1)
                        For Vim version 7+      Last change: 08th Mar 2021

                        By Luc Hermitte
                        hermitte {at} free {dot} fr


==============================================================================
CONTENTS                                      *lhvl-contents*      {{{1
|lhvl-presentation|     Presentation
|lhvl-functions|        Functions

|add-local-help|        Instructions on installing this help file


------------------------------------------------------------------------------
PRESENTATION                                  *lhvl-presentation*  {{{1

|lh-vim-lib| is a library that defines some common Vim functions I use in my
various plugins and ftplugins.
This library has been conceived as a suite of |autoload| plugins, and a few
|macros| plugins. As such, it requires Vim 7+.

As I only have access to a version 7.3-429 on travis-ci, let's say this is the
minimum vim version I'll try to be compatible with.


==============================================================================
FUNCTIONS                                    *lhvl-functions*     {{{1
                                                                        {{{2Functions list~
Miscellanous functions:                                 |lhvl#misc|       {{{2
- |lh#askvim#exe()|
- |lh#askvim#execute()|
- |lh#askvim#execute()|
- |lh#askvim#scriptid()|
- |lh#askvim#scriptnames()|
- |lh#askvim#scriptname()|
- |lh#askvim#where_is_function_defined()|
- |lh#common#check_deps()|
- |lh#common#echomsg_multilines()|
- |lh#common#error_msg()|
- |lh#common#rand()|
- |lh#common#warning_msg()|
- |lh#diff#compute()|
- |lh#encoding#at()|
- |lh#encoding#current_character()|
- |lh#encoding#does_support()|
- |lh#encoding#find_best_glyph()|
- |lh#encoding#iconv()|
- |lh#encoding#previous_character()|
- |lh#encoding#strlen()|
- |lh#encoding#strpart()|
- |lh#env#expand_all()|
- |lh#event#register_for_one_execution_at()|
- |lh#exception#callstack()|
- |lh#exception#callstack_as_qf()|
- |lh#exception#decode()|
- |lh#exception#get_callstack()|
- |lh#file#new_cache()|
- |lh#fmt#printf()|
- |lh#float#min()|, |lh#float#max()|,
  |lh#float#arg_min()|, |lh#float#arg_max()|
- |lh#ft#is_script()|
- |lh#ft#is_text()|
- *lh#has#default_in_getbufvar()* returns whether |getbufvar()| has 3 parameters
- *lh#has#jobs()*     returns whether |+job|s are correctly implemented
- *lh#has#partials()* returns whether |Partial|s are implemented
- *lh#has#vkey()* returns whether |v:key| can be used in |map()| and |filter()|.
- |lh#has#patch()|
- |lh#has#plugin()|
- |lh#lang#set_message_temporarily()|
- |lh#leader#get()|
- |lh#leader#get_local()|
- |lh#leader#set_local_if_unset()|
- |lh#mark#find_first_unused()|
- |lh#mark#is_unused()|
- |lh#math#abs()|
- |lh#mapping#create_toggable_group()|
- |lh#mapping#define()|
- |lh#mapping#plug()|
- |lh#mapping#reinterpret_escaped_char()|
- |lh#mapping#who_maps()|
- |lh#notify#clear_notifications()|
- |lh#notify#deprecated()|
- |lh#notify#once()|
- |lh#on#exit()|
- |lh#po#context()|
- |lh#position#char_at()|
- |lh#position#char_at_mark()|
- |lh#position#char_at_pos()|
- |lh#position#compare()|
- |lh#position#extract()|
- |lh#position#getcur()|
- |lh#position#is_before()|
- |lh#position#move()|
- |lh#position#move_n()|
- |lh#switch#new()|
  - |lh#switch-add_case()|
  - |lh#switch-evaluate()|
- |lh#tags#stack#push()|
- |lh#tags#stack#jump()|
- |lh#time#bench()|
- |lh#time#bench_n()|
- |lh#time#date()|
- |lh#type#name()|
- |lh#visual#cut()|
- |lh#visual#selection()|
Option related functions:                               |lhvl#option|     {{{2
- |lh#option#exists_in_buf()|
- |lh#option#get()|
- |lh#option#get_non_empty()|
- |lh#option#get_from_buf()|
- |lh#option#getbufvar()|
- |lh#option#getbufglobvar()|
- |lh#option#is_set()|
- |lh#option#is_unset()|
- |lh#option#update()|
- |lh#ft#option#get()|
- |lh#ft#option#get_postfixed()|
- |lh#ft#option#get_all()|
- |lh#ref#bind()|
- |lh#ref#is_bound()|
Functor related functions:                              |lhvl#function|   {{{2
- |lh#function#bind()|
- |lh#function#execute()|
- |lh#function#prepare()|
- |lh#partial#execute()|
- |lh#partial#make()|
List related functions:                                 |lhvl#list|       {{{2
- |lh#list#accumulate()|
- |lh#list#Find_if()|, |lh#list#find_if()|, and |lh#list#find_if_fast()|
- |lh#list#Transform()| and |lh#list#transform()|
- |lh#list#arg_min()|, |lh#list#arg_max()|
- |lh#list#chain_transform()|
- |lh#list#concurrent_for()|
- |lh#list#contain_entity()|
- |lh#list#copy_if()|
- |lh#list#cross()|
- |lh#list#equal_range()|
- |lh#list#find_entity()|
- |lh#list#flat_extend()|
- |lh#list#for_each_call()|
- |lh#list#get()|
- |lh#list#intersect()|
- |lh#list#is_contained_in()|
- |lh#list#lower_bound()| and |lh#list#upper_bound()|
- |lh#list#map_on()|
- |lh#list#mask()|
- |lh#list#match()|
- |lh#list#match_re()|
- |lh#list#matches()|
- |lh#list#not_contain_entity()|
- |lh#list#not_found()|
- |lh#list#possible_values()|
- |lh#list#push_if_new()|
- |lh#list#push_if_new_elements()|
- |lh#list#push_if_new_entity()|
- |lh#list#remove()|
- |lh#list#separate()|
- |lh#list#sort()|
- |lh#list#subset()|
- |lh#list#transform_if()|
- |lh#list#uniq()|
- |lh#list#unique_sort()| and |lh#list#unique_sort2()|
- |lh#list#zip()|, and |lh#list#zip_as_dict()|
Dict related functions:                                 |lhvl#dict|       {{{2
- |lh#dict#add_new()|
- |lh#dict#get_composed()|
- |lh#dict#key()|
- |lh#dict#let()|
- |lh#dict#print_as_tree()|
- |lh#dict#need_ref_on()|
- |lh#dict#subset()|
Stack related functions:                                |lhvl#stack|      {{{2
- |lh#stack#push()|
- |lh#stack#pop()|
- |lh#stack#top()|
- |lh#stack#top_or()|
- |lh#stack#new()|, |lh#stack#new_list()|
    - |lh#stack-push()|
    - |lh#stack-pop()|
    - |lh#stack-top()|
    - |lh#stack-top_or()|
String related functions:                               |lhvl#string|     {{{2
- |lh#string#as()|
- |lh#string#count()|
- |lh#string#join()|
- |lh#string#matches()|
- |lh#string#matchstrpos()|
- |lh#string#or()|
- |lh#string#substitute_unless()|
- |lh#string#trim()|
Graph related functions:                                |lhvl#graph|      {{{2
- |lh#graph#tsort#depth()|
- |lh#graph#tsort#breadth()|
Path related functions:                                 |lhvl#path|       {{{2
- |lh#path#add_path_if_exists()|
- |lh#path#cd_without_sideeffects()|
- |lh#path#common()|
- |lh#path#depth()|
- |lh#path#exe()|
- |lh#path#exists()|
- |lh#path#find()|
- |lh#path#find_in_parents()|
- |lh#path#find_upward()|
- |lh#path#fix()|
- |lh#path#glob_as_list()|
- |lh#path#is_absolute_path()|
- |lh#path#is_distant_or_scratch()|
- |lh#path#is_in()|
- |lh#path#is_up_to_date()|
- |lh#path#is_url()|
- |lh#path#join()|
- |lh#path#munge()|
- |lh#path#new_permission_lists()|
- |lh#path#readlink()|
- |lh#path#relative_to()|
- |lh#path#remove_dir_mark()|
- |lh#path#select_one()|
- |lh#path#simplify()|
- |lh#path#split()|
- |lh#path#strip_common()|
- |lh#path#strip_start()|
- |lh#path#to_dirname()|
- |lh#path#to_regex()|
- |lh#path#to_relative()|
- |lh#path#vimfiles()|
- |lh#path#writable()|
Command related functions:                              |lhvl#command|    {{{2
- |lh#command#analyse_args()|
- |lh#command#matching_variables()|
- |lh#command#matching_askvim()|
- |lh#command#matching_for_command()|
- |lh#command#matching_bash_completion()|
- |lh#command#matching_make_completion()|
- |lh#command#new()| (alpha version)
- |lh#command#Fargs2String()| (alpha version)
- |lh#command#complete()| (alpha version)
Menu related functions:                                 |lhvl#menu|       {{{2
- |lh#menu#def_string_item()|
- |lh#menu#def_toggle_item()|
- |lh#menu#text()|
- |lh#menu#make()|
- |lh#menu#IVN_make()|
- |lh#menu#is_in_visual_mode()|
- |lh#menu#map_all()|
- |lh#menu#remove()|
- |lh#askvim#menu()| (beta version)
- |lh#project#menu#def_toggle_item()|
- |lh#project#menu#make()|
- |lh#project#menu#remove()|
Buffer related functions:                               |lhvl#buffer|     {{{2
- |lh#buffer#get_nr()|
- |lh#buffer#list()|
- |lh#buffer#find()|
- |lh#buffer#jump()|
- |lh#buffer#scratch()|
- |lh#buffer#dialog#| functions for building interactive dialogs
    - |lh#buffer#dialog#new()|
    - |lh#buffer#dialog#add_help()|
    - |lh#buffer#dialog#select()|
    - |lh#buffer#dialog#quit()|
    - |lh#buffer#dialog#update()|
Window related functions:                               |lhvl#window|     {{{2
- |lh#window#create_window_with()|
- |lh#window#getid()|
- |lh#window#gotoid()|
- |lh#window#new()|
- |lh#window#split()|
- |lh#window#text_width()|
Quickfix related functions:                             |lhvl#quickfix|   {{{2
- |lh#qf#get_metrics()|
- |lh#qf#get_title()|
- |lh#qf#get_winnr()|
- |lh#qf#is_displayed()|
- |lh#qf#make_context_map()|
- |lh#qf#set_title()|
Syntax related functions:                               |lhvl#syntax|     {{{2
- |lh#syntax#is_a_comment()|
- |lh#syntax#is_a_comment_at()|
- |lh#syntax#getline_matching()|
- |lh#syntax#getline_not_matching()|
- |lh#syntax#line_filter()|
- |lh#syntax#match_at()|
- |lh#syntax#name_at()|
- |lh#syntax#name_at_mark()|
- |lh#syntax#skip()|
- |lh#syntax#skip_at()|
- |lh#syntax#skip_at_mark()|
- |lh#syntax#list_raw()|
- |lh#syntax#list()|
OS/System related functions:                            |lhvl#os|         {{{2
- |lh#async#get_queue()|
- |:Jobs|
- |:JobUnpause|
- |:StopBGExecution|
- |lh#os#has_unix_layer_installed()|
- |lh#os#system_detected()|
- |lh#os#OnDOSWindows()|
- |lh#os#chomp()|
- |lh#os#system()|
- |lh#os#sys_cd()|
- |lh#os#cpu_number()|
- |lh#os#cpu_cores_number()|
- |lh#os#lcd()|
Python related functions                                |lhvl#python|     {{{2
- |lh#python#best_still_avail()|
- |lh#python#has()|
- |lh#python#can_import()|
- |lh#python#external_can_import()|
Completion related functions                            |lhvl#completion| {{{2
- |lh#icomplete#new()|
- |lh#icomplete#new_on()|
- |lh#icomplete#run()|
Log related functions                                   |lhvl#log|        {{{2
- |:LHLog|, |lh#log#set_logger()|
- |lh#log#new()|
- |lh#log#none()|
- |lh#log#callstack()||
- |lh#log#exception()||
- |lh#log#this()||
Version Control System functions                        |lhvl#vcs|        {{{2
- |lh#vcs#get_svn_root()|
- |lh#vcs#get_git_root()|
- |lh#vcs#is_svn()|
- |lh#vcs#is_git()|
- |lh#vcs#get_type()|
- |lh#vcs#get_url()|
- |lh#vcs#decode_github_url()|
- |lh#vcs#as_http()|
OO helpers                                              |lhvl#oo|         {{{2
- |lh#object#make_top_type()|
- |lh#object#inject()|
- |lh#object#inject_methods()|
- |lh#object#to_string()|
- |lh#object#_to_string()|
Variable helper functions                               |lhvl#variable|   {{{2
- |lh#let#if_undef()|
- |lh#let#to()|
- |lh#let#undef()|
Project related definitions                             |lhvl#project|    {{{2
- |p:| |project-variable|
- |:Project|
- |lh#project#define()|
- |lh#project#new()|
- |lh#project#_get()|
- |lh#project#crt_bufvar_name()|
- |lh#project#_crt_var_name()|
- |lh#project#menu#def_toggle_item()|
- |lh#project#menu#make()|
- |lh#project#menu#remove()|
Design by Contract related functions                    |lhvl#DbC|        {{{2
- |lh#assert#mode()|
- |lh#assert#clear()|
- |lh#assert#errors()|
- Assertions:
  - |lh#assert#equal()|
  - |lh#assert#false()|
  - |lh#assert#is()|
  - |lh#assert#false()|
  - |lh#assert#match()|
  - |lh#assert#not_equal()|
  - |lh#assert#true()|
  - |lh#assert#value().empty()|
  - |lh#assert#value().equal()|
  - |lh#assert#value().differ()|
  - |lh#assert#value().is_lt()|
  - |lh#assert#value().is_le()|
  - |lh#assert#value().is_gt()|
  - |lh#assert#value().is_ge()|
  - |lh#assert#value().is_set()|
  - |lh#assert#value().is_unset()|
  - |lh#assert#value().get()|
  - |lh#assert#value().has_key()|
  - |lh#assert#value().match()|
  - |lh#assert#value().not()|
  - |lh#assert#unexpected()|

------------------------------------------------------------------------------
COMMANDS                                              *lhvl#commands*   {{{2
- |:LetIfUndef|
- |:LetTo|
- |:Unlet|
- |:PushOptions|
- |:PopOptions|
}}}2
------------------------------------------------------------------------------
MISCELLANOUS FUNCTIONS                                *lhvl#misc*       {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                       *lh#common#echomsgMultilines()*            {{{3
lh#common#echomsgMultilines()({text}) (*deprecated*)~
                                      *lh#common#echomsg_multilines()*
lh#common#echomsg_multilines()({text})~
@param  {text}      Message to display on several lines
@return             Nothing

This function executes |:echomsg| as many times as required as there are lines
in the original {text}.
This is a workaround |:echomsg| that is unable to handle correctly multi-lines
messages.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#common#ErrorMsg()*            {{{3
lh#common#ErrorMsg({text}) (*deprecated*)~
                                               *lh#common#error_msg()*
lh#common#error_msg({text})~
@param  {text}      Error message to display
@return             Nothing

This function displays an error message in a |confirm()| box if gvim is being
used, or as a standard vim error message through |:echoerr| otherwise.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#common#WarningMsg()*          {{{3
lh#common#WarningMsg({text}) (*deprecated*)~
                                              *lh#common#warning_msg()*
lh#common#warning_msg({text}, [{highlight}])~
@param  {text}      Error message to display
@param  {hl}        Highlight group name, default: `"WarningMsg"`
@return             Nothing

This function displays a warning message highlighted with |WarningMsg| syntax,
or in any other highlight group specified.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#common#CheckDeps()*           {{{3
lh#common#CheckDeps({symbol},{file},{path},{requester}) (*deprecated*)~
                                               *lh#common#check_deps()*
lh#common#check_deps({symbol},{file},{path},{requester})~
@param  {symbol}    Symbol required, see |exists()| for symbol format.
@param  {file}      File in which the symbol is expected to be defined
@param  {path}      Path where the file can be found
@param  {requester} Name of the script in need of this symbol
@return 0/1 whether the {symbol} exists

Checks if {symbol} exists in vim. If not, this function first tries
to |:source| the {file} in which the {symbol} is expected to be defined. If the
{symbol} is still not defined, an error message is issued (with
|lh#common#error_msg()|, and 0 is returned.

Example: >
    if
          \    !lh#common#check_deps('*Cpp_CurrentScope',
          \                     'cpp_FindContextClass.vim', 'ftplugin/cpp/',
          \                     'cpp#GotoFunctionImpl.vim')
          \ || !lh#common#check_deps(':CheckOptions',
          \                     'cpp_options-commands.vim', 'ftplugin/cpp/',
          \                     'cpp#GotoFunctionImpl.vim')
      let &cpo=s:cpo_save
      finish
    endif

Note: Since the introduction of |autoload| plugins in Vim 7, this function has
lost most of its interrest.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#common#rand()*                {{{3
lh#common#rand({max})~
@return a random number in `[0..max[`.
@requires vim to be compiled with |+python| feature.

                                                *lh#diff#compute()*               {{{3
lh#diff#compute({f1}, {f2})~
Computes the difference between two "files", either with `diff` command-line
tool, or with Python difflib
@param[in] {f1} first file, or set of lines, or dictionary
@param[in] {f2} first file, or set of lines, or dictionary
@return a |list| of lines that differ
@since version 5.1.0

The dictionary format is:
- "`file`": filename
- "`lines`": list of lines
- "`name`": test to display when using Python
At least "`file`" or "`lines`" shall be set.

At this time the exact output format is unspecified, and |'diffopt| is
ignored.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#fmt#printf()*                 {{{3
lh#fmt#printf({format}, {args}...)~
@return a formatted string
Unlike |printf()|, this function takes positional parameters, i.e. >

  AssertEquals(lh#fmt#printf("foo bar"), "foo bar")
  AssertEquals(lh#fmt#printf("foo %1 bar", 42), "foo 42 bar")
  AssertEquals(lh#fmt#printf("foo %1 bar %2", 42, "toto"), "foo 42 bar toto")
  AssertEquals(lh#fmt#printf("foo %2 bar %1", 42, "toto"), "foo toto bar 42")
  AssertEquals(lh#fmt#printf("foo %{2.toto}-%{1.titi} bar %1", {'a':42, 'titi': 'tutu'}, {'toto': {'foo': 42}}), "foo {'foo': 42}-tutu bar {'a': 42, 'titi': 'tutu'}")

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#mark#find_first_unused()*     {{{3
lh#mark#find_first_unused()~
@returns The name of the first |mark| found to be _unused_ (as in
`lh#mark#is_unused()`).
The mark names are searched in `A`..`Z` and `a`..`z`.
@version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#mark#is_unused()*             {{{3
lh#mark#is_unused(mark)~
@returns Whether the given |mark| named {mark} is used. A mark is considered to be unused
from the moment `getpos(mark)[1:]` equals `[0, 0, 0]`
@version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#math#abs()*                   {{{3
lh#math#abs(val)~
@returns the absolute value of the number {val}.
@author Troy Curtis Jr

The purpose of the function is to emulate |abs()| on vim version where it
isn't defined.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#mapping#create_toggable_group()* {{{3
lh#mapping#create_toggable_group(group_name)~
@returns a |lhvl#object| that permits to define mappings that can be
deactivated.
@version 5.3.0

It's subservices are:
- *define_map()*  -- `(mode, lhs, rhs, isLocal, isExpr)`
                Defines a new mapping
- *define_imap()* -- `(lhs, rhs, isLocal, isExpr [, isNore])`
                Defines a new insert-mode mapping. In the particular case
                *IMAP* is installed, it'll be used to define the mapping.
- *list_mappings()* -- `(isLocal)`
                Displays the list of mappings defined through this object
- *clear_mappings()* -- `(isLocal)`
                Removes all mappings defined through this object
- *toggle_mappings()*
                Toggle the activation state of the mappings defined through
                this object.
                The activation state is global (multi-buffers), and it'll be
                propagated even to mappings local in buffer other than the
                current one.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#mapping#define()*             {{{3
lh#mapping#define(map_dict)~
Defines a |mapping| from:
- `"mode"`  : i, n, ..
- `"nore"`  : 1/[0]
- `"silent"`: 1/[0]
- `"expr"`  : 1/[0]
- `"buffer"`: 1/[0]
- `"unique"`: 1/[0]
- `"nowait"`: 1/[0]
- `"lhs"`   : keybinding
- `"rhs"`   : action bound
- `"sid"`   : optional number

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#mapping#plug()*               {{{3
lh#mapping#plug(keybinding, name, modes)~
lh#mapping#plug(map_dict, modes)~
Helper function to define in one go several default and unique mappings for a
plug mapping.

For all the mode specified, it's equivalent to: >
    if !hasmapto(name, mode) && (mapcheck(keybinding, mode) == "")
        exe mode.'map <silent> <unique> '.keybinding.' '.name
    endif

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#mapping#reinterpret_escaped_char()* {{{3
lh#mapping#reinterpret_escaped_char(seq)~
This function transforms `'\<cr\>'`, `'\<esc\>'`, ... `'\<{keys}\>'` into the
interpreted sequences `"\<cr>"`, `"\<esc>"`, ...  `"\<{keys}>"`.
It is meant to be used by fonctions like |lh#map#no_context()|,
|lh#map#insert_seq()|, ... as we can not define mappings (/abbreviations) that
contain `"\<{keys}>"` into the sequence to insert.

Note:	It accepts sequences containing double-quotes.

@version 4.0.0, moved from |lh-dev|' |lh#dev#reinterpret_escaped_char()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#mapping#who_maps()*           {{{3
lh#mapping#who_maps(rhs, mode)~
@returns a |List| of mappings (in |maparg()| |dictionary| format) that are
         bound to {rhs} in the specified {mode}.
@version 4.6.0
@see also |hasmapto()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#notify#clear_notifications()* {{{3
lh#notify#clear_notifications()~
Clears previous notifications. Identical notifications will be issued again.
@version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#notify#deprecated()*          {{{3
lh#notify#deprecated(old, new)~
Notifies once that {old} is deprecated and that we should use {new} instead.
@version 4.0.0
>
  call lh#notify#deprecated(
       \ 'lh#dev#reinterpret_escaped_char',
       \ 'lh#mapping#reinterpret_escaped_char')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#notify#once()*                {{{3
lh#notify#once(id [, message])~
Issues a notification once.
@param[in] {id}      Identifier of the notification
@param[in] {message} displayed.
                     Its format is the same as the one taken by |lh#fmt#printf()|
                     When not provided, no message is displayed, the
                     notification itself is left to the calling code.
@return whether a notification has/shall be done.
@version 4.0.0
>
  " Usage 1
  call lh#notify#once('foo', 'Warning: %1 is unexpected %2', what, context)

  " Usage 2
  if lh#notify#once('shy_dalek')
      echomsg "Exterminate"
  endif

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#on#exit()*                    {{{3
lh#on#exit()~
This function will register action to be executed at the end on a scope, and
more precisally in a |:finally| section.
It permits to do the following things:
- *restore()*                       restores a |variable| or a vim |option|.
- *restore_option()*                restores a |lhvl#option.|
- *register()*                      registers: a |command| , or a |funcref|,
                                  or |lhvl#functor| or an object method, to
                                  execute.
                                  It takes a second facultative argument
                                  `"priority"` to give the highest priority to
                                  the command.
- *restore_buffer_mapping()*        restores a |:map-<buffer>|.
- *restore_mapping_and_clear_now()* restores |:map| and |:map-<buffer>| on
                                  `finalize()` and undefine them right away.
- *restore_highlight()*             restores highlight definition like
                                  |CursorLine| one.
- *restore_cursor()*                restores the cursor to its initial position.


Object methods emulates |Partials| on old vim versions. They are specified
with: `{'object': dictionary, 'method': function_name_or_ref}`

e.g. >

   " Here let suppose g:foo exists, but not g:bar
   let l:d = {'a': 1}
   let cleanup = lh#on#exit()
      \ . restore('g:foo')
      \ . restore('g:bar')
      \ . restore(l:d, 'a')
      \ . restore(l:d, 'b')
      \ . register('echo "The END"')
      " note: |function|s can be registered as well
    try
      let g:foo = 1 - g:foo
      let g:bar = 42
      let l:d.a = 12
      let l:d.b = 13
      other actions that may throw
    finally
      call cleanup.finalize()
    endtry
    " Then g:foo and g:bar are restored, "The END" has been echoed
    " l:d.a is restored to 1, and l:d.b is removed

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#lang#set_message_temporarily()* {{{3
lh#lang#set_message_temporarily(value)~
Makes sure |:language| `message` equals {value}.
Returns a |lh#on#exit()| object that restores the message locale to what is was.
@since Version 4.6.4

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#leader#get()*                 {{{3
                                                *lh#leader#get_local()*
lh#leader#get([default='\'])~
lh#leader#get_local([default='\'])~
Returns the value of g:|mapleader| (/resp g:|maplocalleader|), or the default
value otherwise. The default value for the {default} value (sic) for the leader is '\'.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#leader#set_local_if_unset()*  {{{3
lh#leader#set_local_is_unset(value)~
Sets g:|maplocalleader| to {value}, if and only if it isn't already set

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#Exe()*                 {{{3
lh#askvim#Exe({command}) (*deprecated*)~
                                                *lh#askvim#exe()*
lh#askvim#exe({command})~
@param {command}    Command to execute from vim.
@return             What the command echoes while executed.
@note               This function encapsulates |redir| without altering any
                    register.

Some information aren't directly accessible (yet) through vim API
(|functions|).  However, they can be obtained by executing some commands, and
redirecting the result of these commands.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#execute()*             {{{3
lh#askvim#execute({command})~
Portable (to old vim versions) of |execute()| that returns a |List|.
@param {command}    Command to execute from vim.
@return             What the command echoes while executed.
@note               This function encapsulates |redir| without altering any
                    register.

If *lh#askvim#_beware_running_through_client_server()* has been called, and if
|execute()| is not supported by your vim version (v < 7.4-2008)
`lh#askvim#execute()` will return an empty list.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#scriptid()*            {{{3
lh#askvim#scriptid(name)~
@return the id of the script associate to {name}.
@internal Lazily updates `s:scripts`.
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#scriptname()*          {{{3
lh#askvim#scriptname(id)~
@return the name of the script associate to {id}.
@internal Lazily updates `s:scripts`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#scriptnames()*         {{{3
lh#askvim#scriptnames()~
@return |:scriptnames| result as a list of [script_id, name] arrays.
@internal `s:scripts` variables is updated

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#where_is_function_defined()* {{{3
lh#askvim#where_is_function_defined({funcname})~
@return a |dictionary| made of:
    - `'script'`: the scriptname where {funcname} has been defined.
    - `'line'`:   the liner number where {funcname} has been defined in the
                script file, iff the information is available.
                Requires Vim 8.1.0362+
@since Version 4.0.0

If |lh#askvim#_beware_running_through_client_server()| has been called, and if
|execute()| is not supported by your vim version (v < 7.4-2008)
`lh#askvim#where_is_function_defined` will try to decode the name of an
autoloaded function, or return an empty string otherwise.

@note Before v4.6.4, this function was returning a script.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#askvim#menu()*                {{{3
lh#askvim#menu({menuid},{modes})~
@param {menuid}     Menu identifier.
@param {modes}      List of modes
@return             Information related to the {menuid}
@todo               Still bugged

This function provides a way to obtain information related to a menu entry in
Vim.

The format of the result being ?to be stabilized?

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#async#get_queue()*            {{{3
                                                *lh#async#queue()*
lh#async#get_queue(name, policy)~
@since 5.0.0
@warning API changes in v5.0.0
@param[in] {name}   Unique identifier the global queue to obtain
@param[in] {policy} Tells what shall be done when a new job is pushed into a
                    non empty queue. Valid values are:
                    - `'stack'`: push the new job for later
                    - `'replace'`: stop the current job, and start the new one
                    - `'dump'`: ignore the new job
                    - any else will result in the end user being asked what to
                      do.

This first function returns a job queue object that implements a few services
like `push_or_start(job)`, `stop()`... End-users are only expected ot use
|lh#async#queue/push_or_start()|.

                                               *lh#async#queue/push_or_start()*
queue.push_or_start(job)~
This function is a wrapper around recent |job_start()| function. As such it
requires a recent version of Vim without any bugs in the |+job| related part.
I've chosen to require v7.4-1980 at least.

This function implements a queue of jobs to run. Only one job can be ran
simultaneously. When a job has finished, the next one is started.
So far it has been designed to register a |close_cb|, and it has been used
also with a |callback|. There is one default callback provided for |close_cb|
that won't do any thing.

All jobs are started through the |'shell'| in order to support
`cd dirname && cmd` and more complex things.
Under Windows it's ran with `[&shell, &shellcmdflag, command]`
Otherwise, it's ran with `&shell .' '. &shellcmdflag .' '. command`

@param {job} |Dict| that contains:
  - options for |job_start()|
  - `'cmd'`: command to execute
  - `'txt'`: optional description of what is executed for |airline|
  - `'before_starting_cb'`: optional callback for a function to execute before
    starting any new job. Indeed, things that must be executed before a job
    starts shall not be executed before the previous job has ended. This
    callback helps to delay operations written in vim-script language.
  - `'start_fail_cb'`: optional callback executed when starting the job fails.
@todo Support for |job_stop()|

Active queues and background job will be presented in |airline-section|`_b`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *:Jobs*                           {{{3
:Jobs {queue-name}~
Opens a dialog scratch window displaying all jobs being executed in background
and programmed to be executed through |lh#async#queue| feature.

For the moment this window will:
- keep the queue displayed up to date
- permit to cancel jobs with `x`, `<del>` or `d`
- permit to un-pause the job queue with `p`. See |:JobUnpause|.

Eventually, it'll permit to reorganize pending jobs.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *:JobUnpause*                     {{{3
:JobUnpause {queue-name}~
When a process execution fails, if there are pending jobs, the job queue will
be paused if you confirm it.
The only ways to un-pause the queue are through `:JobUnpause` command or
through the |:Jobs| console.

For the moment, the queue cannot be pause voluntarily.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *:StopBGExecution*                {{{3
:StopBGExecution <pattern>~
This command will cancel the first job (registered through |lh#async#queue()|)
it founds that matches the {pattern}.
This command supports |command-completion| to help select the right job.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#po#context()*                 {{{3
lh#po#context([textdomain, textdomaindir])~
@require `&shell == "bash`," otherwise no translation will be performed.
Builds a context that'll permit to translate messages. The default values for
the options will permit to translate Vim messages.

The context permits to request the translation of any messageId from a
.po/.mo file with *lh#po#context().translate()*

For instance, >
    :language mes fr_FR.UTF-8
    :echo lh#po#context().translate('[readonly]')

will print >
    [lecture-seule]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#position#IsBefore()*          {{{3
lh#position#IsBefore({lhs_pos},{rhs_pos})  (*deprecated*)~
                                               *lh#position#is_before()*
lh#position#is_before({lhs_pos},{rhs_pos})~
@param[in]          Positions as those returned from |getpos()|
@return             Whether {lhs_pos} is before {rhs_pos}
@see also |lh#position#compare()| for a result compatible with |sort()|.

                                               *lh#position#compare()*           {{{3
lh#position#compare({lhs_pos},{rhs_pos})~
@param[in]          Positions as those returned from |getpos()|
@return             -1 {lhs_pos} if is before {rhs_pos}
@return             +1 {lhs_pos} if is after  {rhs_pos}
@return              0 {lhs_pos} is at        {rhs_pos}
@see also |lh#position#is_before()| for a boolean result.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#position#char_at()*           {{{3
lh#position#char_at({lig}, {col}~
@return             The character at a given position.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#position#CharAtMark()*        {{{3
lh#position#CharAtMark({mark})  (*deprecated*)~
                                             *lh#position#char_at_mark()*
lh#position#char_at_mark({mark})~
@return             The character at a given |mark|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#position#CharAtPos()*         {{{3
lh#position#CharAtPos({pos})  (*deprecated*)~
                                              *lh#position#char_at_pos()*       {{{3
lh#position#char_at_pos({pos})~
@return             The character at a position (see |getpos()|).

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#position#extract()*           {{{3
lh#position#extract({pos1}, {pos2})~
@return             The string between the two positions (see |getpos()|).

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#position#getcur()*            {{{3
lh#position#extract({pos1}, {pos2})~
@return             |getcurpos()| when it exists, |getpos()| otherwise.
@since              Version 4.1.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#position#move()*              {{{3
lh#position#move({direction})~
@param {direction}  should be either `"\<right>"` or `"\<left>"`.
@return             a string that can be used to move the cursor in the specified direction
                    If vim version is >= 7.4.849, the movement can be
                    repeated/redone (see |redo-register|).
@since              Version 4.4.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#position#move_n()*            {{{3
lh#position#move_n({direction}, {count})~
@param {direction}  should be either `"\<right>"` or `"\<left>"`.
@param {count}      number of positions the cursor shall be moved
@return             a string that can be used to move the cursor in the specified direction
                    If vim version is >= 7.4.849, the movement can be
                    repeated/redone (see |redo-register|).
@since              Version 4.4.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#switch#new()*                 {{{3
lh#switch#new([{cases}...])~
@param {cases}  passed to |lh#switch-add_case()|
@return a switch |lhvl#object| with two services: |lh#switch-add_case()| and
|lh#switch-evaluate()|.
@since              Version 4.7.1

                                             *lh#switch-add_case()*                 {{{4
lh#switch-add_case({case})~
@param {case}  |Dictionary| made of the two keys
- `'cond'`:     predicate taking N parameters
- `'function'`: |function| reference, or |string| that can be |eval()|uated,
              taking N parameters.
@return |v:true|/1 or |v:false|/0
@pre The number of parameters N shall match the number of parameters that will
be passed to |lh#switch-evaluate()| method.

If |lambas| are not supported in your version of vim, you can still define
string that'll get evaluated. The parameters can be accessed through |a:000|
... manipulated as a |string.| e.g. >

    let switch = lh#switch#new()
    call switch.add_case({'cond': {d -> d.conv}, 'func': '"converting constructor from ".a:1.params[0].spelling'})
    call switch.add_case({'cond': 'a:1.dtr'    ,  'func': '"a destructor"'})
    call switch.add_case({'cond': 1            ,  'func': '"0"'}) " default case...

    let ctr = {'name': 'MyClass', 'params': [{'spelling': 'double'}], 'ctr': 1, 'dtr': 0}
    AssertEqual (switch.evaluate(extend(copy(ctr), {'conv': 1})), 'converting constructor from double')
    AssertEqual (switch.evaluate(extend(copy(ctr), {'conv': 0})), 'a constructor')
    AssertEqual (switch.evaluate({'conv': 0, 'ctr':0, 'dtr': 1}), 'a destructor')
    AssertEqual (switch.evaluate({'conv': 0, 'ctr':0, 'dtr': 0}), '0')

Never forget to make sure all possible cases are coverred. A "default" case
may be reduired.

                                             *lh#switch-evaluate()*                 {{{4
lh#switch-evaluate({args}...)~
@param {args}  N parameters that'll be passed to the `'cond'` predicate and
`'function'` registered previously with |lh#switch-add_case()|.
@pre The number of parameters N shall match the number of parameters that will
be passed to the predicates and the functions registered.

This method will first check the first case registered (in order), with a
predicate that evaluates to 1/|v:true|.

Then, it will evaluate its associated `'function'` and return its value.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#tags#stack#jump()*            {{{3
lh#tags#stack#jump(tagentry [, cmd = 'tag'])~
Forge a new tag entry in the tag stack and jump to it with the specified
command.
@param {tagentry} tag entry as returned by |taglist()|, expected keys: '`cmd`'
                  and `'filename`
@param {cmd}      tag command to use to jump to the tagentry, defaults to
                  |:tag|. See |tag-matchlist| commands regarding the valid
                  alternatives.

@pre The number of entries already forced < 1 million
@since Version 4.6.0, used to belong to |lh-tags|

Typical use: once a we know which function overload we wish to jump to, we can
give an unique id to that overload and jump to it.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#tags#stack#push()*            {{{3
lh#tags#stack#push(tagentry)~
Forge a new tag entry in the tag stack.
@param {tagentry} tag entry as returned by |taglist()|, expected keys: '`cmd`'
                  and `'filename`
@pre The number of entries already forced < 1 million
@since Version 4.6.0, used to belong to |lh-tags|

This function is used by |lh#tags#stack#jump()|, but still publicly exposed.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#time#bench()*                 {{{3
lh#time#bench(Function[, args])~
@return the time spent by the execution of `Function()`.
@param[in] {Function} is expected to be something like a |function| --
|lhvl-functor|s are not yet supported.
@require |reltime()| support (hence, a recent Vim version)
@since Version 3.14.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#time#bench_n()*               {{{3
lh#time#bench_n(n Function[, args])~
@return the time spent by the execution of `Function()` n times.
@param[in] {n}        Number of times the function call is benched.
@param[in] {Function} is expected to be something like a |function| --
|lhvl-functor|s are not yet supported.
@require |reltime()| support (hence, a recent Vim version)
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#time#date()*                  {{{3
lh#time#date()~
@return the equivalent of `strftime('%D-th %b %Y)`

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#type#name()*                  {{{3
lh#type#name(type-value)~
@returns the name that describes best the type associated to the |type()| value provided.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#visual#selection()*           {{{3
lh#visual#selection()~
@return             The current visual selection
@post              |registers| are not altered by this function

                                                *lh#visual#cut()*                 {{{3
lh#visual#cut()~
@return             The current visual selection
@post              |registers| are not altered by this function ;
                    selection is deleted.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#does_support()*      {{{3
lh#encoding#does_support(chars, [, fonts=&guifont])~
Tries to detect automatically whether a codepoint has an associated glyph in
the current font used.
@since Version 4.5.0
@param[in] {chars}   |List| of characters expressed either as `"\uHEXA"`, or
                     `"\UHEXA"`, or `'U+HEXA'`.
@param[in] [{fonts}] Regex that define active fonts. Defaults to |'guifont'|
                     when `has('gui_running')` is true
@return              |Dictionary| where the keys are the codepoints, and the
                     values are 0/1 depending whether the font supports that character.

Examples: >
    :echo lh#encoding#does_support(["\u274c", "U+1F6C8"])

Requires:
- |gvim|
    Unfortunatelly this feature requires a way for Vim to know which is the
    current font. This is impossible to do so in a portable way from the
    terminal.  This means, unless you know which font your terminal is using,
    it'll uses |'guifont'| which is available only from GUI sessions, IOW when
    we use `gvim`, and not `vim`.
- Python (external) with `python-fontconfig` module installed (and thus
  `fontconfig`)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#find_best_glyph()*   {{{3
lh#encoding#find_best_glyph(caller, glyphs...)~
Returns the first codepoint of each list that has a glyph in the current font
used.
@since Version 4.5.0
@param[in] {caller} name the plugin in the need the information for richer
                    error messages
@param[in] {glyphs} |list| of |list| of codepoints. The characters can be
                    expressed either as `"\uHEXA"`, or `"\UHEXA"`, or `'U+HEXA'`.
@return             |list| of matching codepoints -- taken from the inputs.
                    When no codepoint is found to have a glyph in a |list|,
                    then the last value (that can be a string, and not a
                    codepoint) is returned.
Same requirements as |lh#encoding#does_support()| upon which this function
rely.

Examples: >
    let s_error   = s:opt('signs.error',   ["\u274c", 'XX']           )
    let s_warning = s:opt('signs.warning', ["\u26a0", "\u26DB", '!!'] )
    let s_note    = s:opt('signs.note',    ["\u2139", "\U1F6C8", 'ii'])
    let s_context = s:opt('signs.context', ['>>']                     )
    let s_info    = s:opt('signs.info',    ["\u27a9", '->']           )

    let [error, warning, note, ctx, here] = lh#encoding#find_best_glyph(
          \ 'compil-hints',
          \ s_error, s_warning, s_note, s_context, s_info
          \ )

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#iconv()*             {{{3
lh#encoding#iconv({expr}, {from}, {to})~
This function just calls |iconv()| with the same arguments. The only
difference is that it return {expr} when we know that |iconv()| will return an
empty string.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#strlen()*            {{{3
lh#encoding#strlen({mb_string})~
This function returns the length of the multi-bytes string.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#at()*                {{{3
lh#encoding#at({mb_string}, {i})~
Returns the i-th character in a multi-bytes string.
@param {i} 0-indexed offset.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#strpart()*           {{{3
lh#encoding#strpart({mb_string}, {position}, {length})~
Returns {length} extracted characters from {position} in a multi-bytes string.
@param {position} 0-indexed offset.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#encoding#current_character()* {{{3
                                                *lh#encoding#previous_character()*
lh#encoding#current_character()~
lh#encoding#previous_character()~
Returns The character under/before the current.
Works even with multi-byte characters

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#env#expand_all()*             {{{3
lh#env#expand_all({string})~
Parses and replaces environment variable occurrences by the values found.
Some hooks are defined for specific filetypes
- `cmake` : if |lh-cmake| is installed, uses |lh#cmake#get_variables()| to
          convert `${varname}` expression.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                 *lh#event#RegisterForOneExecutionAt()*           {{{3
lh#event#RegisterForOneExecutionAt({event}, {cmd}, {group})  (*deprecated*)~
                                 *lh#event#register_for_one_execution_at()*
lh#event#register_for_one_execution_at({event}, {cmd}, {group})~
Registers a command to be executed once (and only once) when {event} is
triggered on the current file.

@param {event} Event that will trigger the execution of {cmd}|autocmd-events|
@param   {cmd} |expression-command| to execute
@param {group} |autocmd-groups| under which the internal autocommand will be
               registered.
@todo possibility to specify the file pattern

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#exception#get_callstack()*    {{{3
lh#exception#get_callstack()~
Extracts the current callstack by throwing a dummy exception in order to
analyse its |v:throwpoint| with |lh#exception#decode()|.
@see also |lh#exception#callstack()|, |lh#exception#decode()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#exception#decode()*           {{{3
lh#exception#decode([throwpoint])~
Returns an |lh#oo| object storing a decoded callstack (with
|lh#exception#callstack()|).
This objects provides the following methods:
- `__pop()` (internal): remove the first callsite in the callstack (useful to
  clean noise from intermediary functions)
- `as_qf()`: return the callstack as a list compatible with |setqflist()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#exception#callstack()*        {{{3
lh#exception#callstack({throwpoint})~
Decodes the {throwpoint} and returns a list of dictionaries made of:
- "`script`": name of the file where the exception comes from
- "`pos`"   : abolute line number in the script where the exception has been issued
- "`fname`" : name of the function where the exception has been issued
- "`offset`": Relative line number from the function first line where the
  exception....
@see also |lh#exception#callstack_as_qf()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#exception#callstack_as_qf()*  {{{3
lh#exception#callstack_as_qf({filter} [{msg}])~
Decodes the current callstack and returns a list of dictionaries compatible
with |setqflist()| and |setloclist()|.
Entries with a `fname` field  matching `'\vlh#exception#'.{filter}` will be
filtered out. If you plan to use this field, don't forget to prepend with
a `/\|`, (magic mode).
@see also |lh#exception#callstack()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                               *lh#file#new_cache()*             {{{3
lh#file#new_cache({update-function})~
Returns a new object that can caches data associated to files.
@param {update-function} shall be a callable object that takes one parameter
(a filename) and return data it want to associated to it.

Data associated to a file can be retrieved with `get(filename)`, it be
either computed on-the-fly if the data is not up-to-date, or returned from the
cache. *lh#file#new_cache().get()*

Example: >
    function! s:get_make_compl(makefile) dict abort
      let dir = fnamemodify(a:makefile, ':h')
      let completions = split(lh#command#matching_bash_completion('make', '', dir), "\n")
      call lh#list#unique_sort(completions))
      return completions
    endfunction

    let s:make_cache = lh#file#new_cache(function(s:getSNR('get_make_compl')))

    function! lh#command#matching_make_completion(lead, ...) abort
      let makefile = (a:0 > 0 ? a:1.'/' : '') . 'Makefile'
      let makefile = fnamemodify(makefile, ':p')
      let matches = copy(s:make_cache.get(makefile))
      call filter(matches, 'v:val =~ "^".a:lead')
      return matches
    endfunction

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                               *lh#float#max()*     *lh#float#min()*             {{{3
                               *lh#float#arg_max()* *lh#float#arg_min()*
lh#float#min({list})~
lh#float#arg_min({list})~
lh#float#min({list})~
lh#float#arg_min({list})~
Returns The minimum, /arg-minimum, /maximum, /arg-maximum of a |List| of
|expr-float|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                *lh#ft#is_text()*                                 {{{3
lh#ft#is_text([ft])~
Tells whether the corresponding filetype correspond to a text filetype.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                *lh#ft#is_script()*                               {{{3
lh#ft#is_text([ft])~
Tells whether the corresponding filetype correspond to a script filetype (sh,
python, ruby, perl).

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                *lh#has#patch()*                                  {{{3
lh#has#patch('patch-{ver}.{patch})~
@since Version 4.0.0
Provides a portable layer over |has-patch| improved detection added in patch
7.4-236 and 7.4-237.
In other, `has('patch-7.4.001')` won't work, while `lh#has#patch('patch-7.4.001')` will.
Note however, that this function isn't required since Version 7.4-237.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                *lh#has#plugin()*                                 {{{3
lh#has#plugin(name)~
@since Version 4.7.1
Tells whether a file is present in 'runtimepath'.

------------------------------------------------------------------------------
OPTION RELATED FUNCTIONS                              *lhvl#option*     {{{2
This sub-library helps fetching option values for plugins.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#exists_in_buf()*       {{{3
lh#option#exists_in_buf({expr}, {name})~
@return what `exists({name})` would return when the current buffer matches
{expr}.
This function encapsulates  |getbufvar| >

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#Get()*                 {{{3
lh#option#Get({names},{default}[,{scopes}])  (*deprecated*)~
                                                *lh#option#get()*
lh#option#get({names}[,{default}[,{scopes}]])~
@param {name}       Names of the option to fetch
@param {default}    Default value in case the option is not defined.
                    Its default value is |g:lh#option#unset|.
@param {scopes}     Vim scopes in which the options must be searched,
                    default="bpg".
@return             b:{names[0]} if it exists, or b:{names[1...]} if any
                    exist, or p:{names[0...]} if any exist, or g:{names[0...]}
                    if any exist, or {default} if none exists.
@see                For development oriented options, |lh-dev| provides a
                    dedicated function: |lh#dev#option#get()|.

This function fetches the value of an user defined option (not Vim |options|).
The option can be of any variable kind between |g:|, |b:|, |w:|, |t:| or lh-vim-lib |p:|.
If the option is bound to another variable, it'll be resolved to return the
other variable value. See |lh#ref#bind()|.

The order of the variables checked can be specified through the optional
argument {scopes}. By default, buffer-local options have the priority over
global options.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#option#GetNonEmpty()*         {{{3
lh#option#GetNonEmpty({name},{default}[,{scopes}])  (*deprecated*)~
                                              *lh#option#get_non_empty()*
lh#option#get_non_empty({name}[,{default}[,{scopes}]])~
@param {name}       Name of the option to fetch
@param {default}    Default value in case the option is not defined, nor empty
                    Its default value is |g:lh#option#unset|.
@param {scopes}     Vim scopes in which the options must be searched,
                    default="bg".
@return b:{name}    If it exists, of g:{name} if it exists, or {default}
                    otherwise.

This function works exactly like |lh#option#get()| except that a defined
variable with an empty value will be ignored as well.
An |expr-string| will be considered empty if its |strlen()| is 0, an
|expr-number| when it values 0, |Lists| and |Dictionaries| when their |len()|
is 0.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#get_from_buf()*        {{{3
lh#option#get_from_buf({bufid}, {name}[,{default}[,{scopes}]])~
@param {bufid}      Buffer identifier (name of number)
@param {name}       Name of the option to fetch
@param {default}    Default value in case the option is not defined.
                    Its default value is |g:lh#option#unset|.
@param {scopes}     Vim scopes in which the options must be searched,
                    default="bpg".
@return             {b}:{name} if it exists, or p:{var} if it exists, or
                    g:{name} if it exists, or {default} otherwise.
@see                For development oriented options, |lh-dev| provides a
                    dedicated function: |lh#dev#option#get()|.

This function works exactly as |lh#option#get()| except that it searches the
`b:var` and `p:var` into the {bufid} buffer.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#getbufvar()*           {{{3
lh#option#getbufvar({expr}, {name}[,{default}])~
This function encapsulates  |getbufvar| >
    getbufvar(expr, name, g:lh#option#unset)

Unlike the direct call of the previous expression, this function ensures
|g:lh#option#unset| is known (the lazy-loading mecanism of autoload plugins
doesn't apply to variables, only to functions).
See also |lh#option#getbufglobvar()|.

                                                *lh#option#getbufglobvar()*       {{{3
lh#option#getbufglobvar({expr}, {name}[,{default}])~
This function is a crossover between |lh#option#getbufvar()| and
|lh#option#get()|. The later searches in the current buffer for a given
buffer-local variable. Sometimes, we want to search into another well known
buffer without having to change the current buffer, and still search in the
global variables.

This function encapsulates  |getbufvar| >
    getbufvar(expr, name, get(g:, name, g:lh#option#unset))

Unlike the direct call of the previous expression, this function ensures
|g:lh#option#unset| is known (the lazy-loading mecanism of autoload plugins
doesn't apply to variables, only to functions)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#is_set()*              {{{3
                                                *lh#option#is_unset()*
lh#option#is_set({expr})~
lh#option#is_unset({expr})~
@return whether expr is defferent (/resp identical) to |g:lh#option#unset|.
This function will permit to test whether an option is set or not: >
    silent! unlet g:foobar
    Assert lh#option#is_unset(lh#option#get('foobar'))
    let g:foobar = 1
    Assert lh#option#is_set(lh#option#get('foobar'))

    silent! unlet b:foobar
    Assert lh#option#is_unset(lh#option#getbufvar('%', 'foobar'))
    let b:foobar = 1
    Assert lh#option#is_set(lh#option#getbufvar('%', 'foobar'))

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#update()*              {{{3
lh#option#update({bid}, {varname}, {value})~
@param {bid} buffer id
@param {varname} Name of the option to update
@param {value}   Assignment to apply to the option
@since version 5.3.1

Examples: >
   call lh#option#update(bufnr('%'), '&tags',    '+=~/tags,/opt/some/project/tags')
   call lh#option#update(bufnr('%'), '&isfname', '+={,}')
   call lh#option#update(bufnr('%'), '&isfname', '-==')
   call lh#option#update(bufnr('%'), '&cindent', '=1') " or:
   call lh#option#update(bufnr('%'), '&cindent', '1')  " without the "="
   call lh#option#update(bufnr('%'), 'foo',      '=somevalue')      " b:foo
   call lh#option#update(bufnr('%'), 'bar',      '=someothervalue') " b:bar

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#ft#option#get()*              {{{3
lh#ft#option#get({name}, {ft}[, {default} [,{scopes}]])~
@return which ever exists first among: b:{ft}_{name}, or p:{ft}_{name}, or
g:{ft}_{name}, or b:{name}, or p:{name}, or g:{name}. {default} is returned
if none exists.
@note filetype inheritance is supported -- see |lhdev-filetype|.
The order of the scopes for the variables checked can be specified through the
optional argument {scope}
@see also |lh#ft#option#get_postfixed()|
@see also |lh#ft#option#get_all()|
@since Version 4.0.0, moved from |lh-dev| `lh#dev#option#get()`.

Example: >
    LetTo g:foo.glob        = 'g'
    LetTo g:foo.spe_buff    = 'g'
    LetTo g:foo.spe_gFT     = 'g'
    LetTo g:FT_foo.gFT      = 'gft'
    LetTo g:FT_foo.spe_gFT  = 'gft'
    LetTo g:FT_foo.spe_bFT  = 'gft'
    LetTo b:foo.buff        = 'b'
    LetTo b:foo.spe_buff    = 'b'
    LetTo b:foo.spe_bFT     = 'b'
    LetTo b:FT_foo.bFT      = 'bft'
    LetTo b:FT_foo.spe_bFT  = 'bft'

    let d = lh#ft#option#get_all('foo', 'FT')

    AssertEquals(d.glob,     'g')
    AssertEquals(d.buff,     'b')
    AssertEquals(d.spe_buff, 'b')
    AssertEquals(d.gFT,      'gft')
    AssertEquals(d.spe_gFT,  'gft')
    AssertEquals(d.bFT,      'bft')
    AssertEquals(d.spe_bFT,  'bft')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#ft#option#get_postfixed()*    {{{3
lh#ft#option#get({name}, {ft}, {default} [,{scopes}])~
@return which ever exists first among: b:{name}_{ft}, or p:{name}_{ft}, or
g:{name}_{ft}, or b:{name}, or p:{name}, or g:{name}. {default} is returned
if none exists.
@note filetype inheritance is supported -- see |lhdev-filetype|.
The order of the scopes for the variables checked can be specified through the
optional argument {scope}
@see also |lh#ft#option#get()|
@since Version 4.0.0, moved from |lh-dev| `lh#dev#option#get_postfixed()`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#ft#option#get_all()*          {{{3
lh#ft#option#get_all({name} [, {ft}})~
Considering that the following variables will be |dictionaries| -- expecting they
exists --, this function will merge all their values into one, keeping the
most specialized value when there are.
Possible variable names: b:{ft}_{name}, or p:{ft}_{name}, or g:{ft}_{name}, or
b:{name}, or p:{name}, or g:{name}.
@note filetype inheritance is supported -- see |lhdev-filetype|.
The order of the scopes for the variables checked can be specified through the
optional argument {scope}
@see also |lh#ft#option#get()|
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#ref#bind()*                   {{{3
lh#ref#bind(varname)~
lh#ref#bind(dict, key)~
This function builds a reference to another variable.
The long term objective is to be able to have global preferences, and project
specific preferences that either default to the global ones, or that can be
overriden.
A bound value shall be obtained with |lh#option#get()| and
|lh#dev#option#get()| functions.

The first overload builds a symbolic link to a named variables.
The second overload build a link to the soft-linked {key} relative to the
hard-linked |dictionary| variable.

The linked variable can be interrogated with `ref.resolve()`, or assigned with
`ref.assign(value)`.

*lh#ref#is_bound()* tells whether its parameter is the name of a variable bound to another.

Example: >
    let g:dummy = [1,2,3]

    " What we don't want
    let b:dummy = g:dummy
    Assert ! lh#ref#is_bound(b:dummy)
    AssertEqual(lh#option#get('dummy'), g:dummy)
    let g:dummy = [1, 2, 3, 4]
    AssertDiffer(lh#option#get('dummy'), g:dummy)

    " What we want!
    let b:dummy = lh#ref#bind('g:dummy')
    Assert lh#ref#is_bound(b:dummy)
    AssertEqual(lh#option#get('dummy'), g:dummy)
    let g:dummy = [1, 2, 3, 4, 5]
    AssertEqual(lh#option#get('dummy'), g:dummy)


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#option#unset()*
                                                *g:lh#option#unset*
lh#option#unset()~
@return the value |g:lh#option#unset|, that can be tested with
|lh#option#is_set()|and |lh#option#is_unset()|.
@note Never use |g:lh#option#unset| from your plugins but |lh#option#unset()|
as it will get lazily loaded on need.

------------------------------------------------------------------------------
FUNCTOR RELATED FUNCTIONS                             *lhvl#function*   {{{2

This sub-library helps defining functors-like variables, and execute them.

NB: C++ developpers may be already familiar with `boost.bind`
(/`std(::tr1)::bind`) function that inspired by feature.
Since Vim has introduced closures on |lambda|s, this feature isn't as
interresting as it used to be.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                      *lhvl#functor*              {{{3
A functor is implemented as a |Dictionary| that has the following fields:
- {execute}  is the |Funcref| that will be actually executed by
             |lh#function#execute()|. Its only argument is a |List| of
              arguments for {function}.
- {function} that identifies the function to execute,
              internals: it could be either a |Funcref|or a |expr-string|, or
              whatever is compatible with the {execute} |FuncRef| field.
- {args}     will contain the binded arguments as defined by
             |lh#function#bind()|. If you attach a {execute} function of your
              own to a functor, you don't need to fill "args".

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#function#bind()*              {{{3
lh#function#bind({fn} [, {arguments} ...])~
This function creates a new |lhvl#functor| based on a given function {fn}, and
where some arguments are binded to the ones from {arguments}.
The result is a new function-like data having for parameter v:1_, v:2_, ...
that were specified in |lh#function#bind()| {arguments} list.

Examples:~
   See tests/lh/function.vim

Let's suppose Print(...) a Vim variadic function that echoes the arguments it
receives, i.e. >
   call Print(1,2,"text", ['foo', 'bar'])
will echo: >
   1 ## 2 ## 'text' ## ['foo', 'bar']

* Binding a |FuncRef|:~
  and reverse the arguments given to it when it will be executed >
   >:let func = lh#function#bind(function('Print'), 'v:3_', 'v:2_', 'v:1_')
   >:echo lh#function#execute(func, 1, 'two', [3])
   [3] ## 'two' ## 1

* Binding a named function:~
  the new function has 3 parameters and calls the named function with its 3rd
  parameter, 42, its second and its first parameters as arguments. >
   >:let func = lh#function#bind('Print', 'v:3_', 42, 'v:2_', 'v:1_')
   >:echo lh#function#execute(func, 1, 'two', [3])
   [3] ## 42 ## 'two' ## 1
< NB: if `exists('*'.func_name)` is false, then the string is considered to be
  an expression that will be evaluated as specified in the next use case.

* Binding an expression:~
  This time more complex on-the-fly computations on the |lhvl#functor|
  parameters can be accomplished >
   >:let func = lh#function#bind('Print(len(v:3_), 42, v:2_, v:1_)')
   >:echo lh#function#execute(func, 1, 'two', [1,2,3])
   3 ## 42 ## 'two' ## 1
< NB: func["args"] is defined, but empty, and unused.
 NB: |v:val| is supported as well.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#function#execute()*           {{{3
lh#function#execute({functor} [, {arguments} ...])~
While |lh#function#bind()| defines a |lhvl#functor| that can be stored and
used later, |lh#function#execute()| directly executes the {functor} received.

Different kind of {functors} are accepted:
- |FuncRef|, and function names, where arguments are |lh#function#execute()|
  ones ;
- |expr-string|, where "v:{pos}_" strings are binded on-the-fly to {arguments} ;
- |lhvl#functor|, that will be given {arguments} as arguments.

Examples:~
   See tests/lh/function.vim

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#function#prepare()*           {{{3
lh#function#prepare({function}, {arguments} ...)~
This function expands all the elements from the {arguments} |List|, and
prepares a |expr-string| that once evaluated will call the n-ary {function}
with the n-{arguments}.
The evaluation is meant to be done with |eval()|.
>
   >:let call = lh#function#prepare('Print', [1,2,"foo"])
   >:echo eval(call)
   1 ## 2 ## 'foo'

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                       *lh#partial#execute()* *lh#partial#make()* {{{3
lh#partial#make({function}, {arguments})~
lh#partial#execute({partial} [, {arguments}])~
`lh#partial#make()` builds either a |Partial| or an object that'll emulate a
partial if they are not supported in you current version of Vim.

While partials can be directly evaluated with: >
    let Cb = lh#partial#make('has', ['gui_running'])
    echo Cb()

There is no guarantee it'll work if vim version is < 7.4-1558.
The right way to evaluate this partial is with: >
    echo lh#partial#execute(Cb)

On this same topic, see also |lh#function| feature which permits parameter
reordering.

------------------------------------------------------------------------------
STRING RELATED FUNCTIONS                              *lhvl#string*     {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#count_char()*          {{{3
lh#string#count_char({string}, {char} [, {ic}])~
@return the number of occurences the character {char} in the {string}
received. The search can be case insensitive if {ic} is true.
@since Version 4.2.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#as()*                  {{{3
lh#string#as(val)~
@param    {val} any value/expression.
@return the {val} as a string. Unlike |string()| function, this one doesn't
add quotes around strings.

@note if {val} is a |Dict| that has a field named `"_to_string"`, this field
will be used and called a member function whose result will be returned.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#join()*                {{{3
lh#string#join(sep, strings...)~
@return the non-empty {strings} separated by {sep}
@since Version 5.2.0
Works as |join()| but on |string|s instead of a |List| of |string|s.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#matches()*             {{{3
lh#string#matches(string, pattern)~
@param    {string} |expr-string|
@param   {pattern} |expr-string|
@return            A |List| of all substrings that match {pattern} in {string}
@return            An empty list if there is no match

Example: >
   let matches = lh#string#matches('sqjg %1 msqkg ml %2 mihs m%43%8', '%\zs\d\+')
   let expected= ['1', '2', '43', '8']
   AssertEquals(matches, expected)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#matchstrpos()*         {{{3
lh#string#matchstrpos(expr, pattern [, start [, count]])~
Backports |matchstrpos()| to old versions of vim.
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#or()*                  {{{3
lh#string#or([strings...])~
@return the first non empty string
@since Version 4.6.4

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#substitute_unless()*   {{{3
lh#string#substitute_unless(string, pat, char)~
@param    {string} |expr-string|
@param       {pat} |regexp|
@param      {char} character (any string will do though)

This is somehow the equivalent of >
    substitute(string, '[^{pat}]', char', 'g')
except |substitute()| doesn't accept this syntax to replace patterns that
don't match.
Note that the pattern will be applied on each character independently of the
others.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#string#trim()*                {{{3
lh#string#trim(string)~
@param    {string} |expr-string|
@return            {string} trimmed of spaces

------------------------------------------------------------------------------
STACK RELATED FUNCTIONS                               *lhvl#stack*      {{{2
Stacks functions helps to implement the LIFO/FILO ADT type.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#stack#push()*                 {{{3
lh#stack#push({stack}, {value})~
Push a new value into the stack.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#stack#pop()*                  {{{3
lh#stack#pop({stack})~
@pre `!empty({stack})`
Removes a value from the stack and returns it.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#stack#top()*                  {{{3
lh#stack#top({stack})~
@pre `!empty({stack})`
@see |lh#stack#top_or()|
Returns the top value of the stack.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#stack#top_or()*               {{{3
lh#stack#top_or({stack}, {default})~
@see |lh#stack#top_or()|
Returns the top value of the stack, or the {default} value if the stack is
empty.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#stack#new()*                  {{{3
lh#stack#new([{values}])~
Returns a new stack object on which the usual methods can be called:
- `empty()`           returns if empty     *lh#stack-empty*
- `len()`             returns nb elements  *lh#stack-len*
- `push({value})`                          *lh#stack-push* ,    see |lh#stack#push()|
- `pop()`                                  *lh#stack-pop* ,     see |lh#stack#pop()|
- `pop_or({default})`                      *lh#stack-pop_or* ,  see |lh#stack#pop_or()|
- `top()`                                  *lh#stack-top* ,     see |lh#stack#top()|
NB: the {values} parameter is optional.
>
   let s = lh#stack#new([12, 42])
   echo s.len()    " -> 2
   echo s.empty()  " -> 0
   echo s.top()    " -> 42
   echo s.pop()    " -> 42
   echo s.len()    " -> 1
   echo s.empty()  " -> 0
   echo s.top()    " -> 12
   call s.push(48)
   echo s.len()    " -> 2
   ...


------------------------------------------------------------------------------
                                                *lh#stack#new_list()*             {{{3
lh#stack#new_list({nb_stacks})~
Returns a new object that implements a list a stacks.
The usual operations can be called on the indexed stacks. See |lh#stack#new()|.
NB: the {values} parameter is optional.
>
   let s = lh#stack#new_list(10)
   echo s.nb_stacks()            " -> 10
   echo s.len(3)                 " -> 0
   call s.push(3, 42)
   echo s.len(3)                 " -> 1
   echo s.top(3)                 " -> 42
   echo s.empty(0)               " -> 1

   call s.push([1,5], 28)
   echo s.empty(0)               " -> 1
   echo s.empty(6)               " -> 1
   echo s.top(3)                 " -> 28
   echo s.pop(5)                 " -> 28
   ...

Other functions are also provded:
>
  " Clear a list, and ensure 28 elements
  s.clear(28)
  " Augment the size to hold 12 more elements
  s.expand(12)

------------------------------------------------------------------------------
LIST RELATED FUNCTIONS                                *lhvl#list*       {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#Match()*                  {{{3
lh#list#Match({list},{pattern}[, {start-pos}])  (*deprecated*)~
                                                *lh#list#match()*
lh#list#match({list},{pattern}[, {start-pos}])~
@param      {list} |List|
@param   {pattern} |expr-string|
@param {start-pos} First index to check
@return            The lowest index, >= {start-pos}, in |List| {list} where
                   the item where {pattern} matches.
@return            -1 if no item is matched by {pattern}.
@see |index()|, |match()|, |lh#list#match_re()|

Starting from Vim 7.3, this function forwards all its parameters to |match()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#match_re()*               {{{3
lh#list#match_re({list}, {to_be_matched}[, {start-pos}])~
@param          {list} |List| of regexes
@param {to-be-matched} |expr-string|
@param     {start-pos} First index to check
@return                The lowest index, >= {start-pos}, in |List| {list}
                       where the |regexp| item matches {to-be-matched} text.
@return                -1 if no regexp item matches ey {to-be-matched}.
@since Version 3.2.4
@see |index()|, |match()|, |lh#list#match()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#matches()*                {{{3
lh#list#match({list},{pattern}[, {start-pos}])~
@param      {list} |List|
@param   {pattern} |expr-string|
@param {start-pos} First index to check
@return            The |List| of indices, >= {start-pos}, in |List| {list} where
                   the item matches {pattern}.
@return            [] if no item matches {pattern}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        *lh#list#contain_entity()*         {{{3
                                        *lh#list#not_contain_entity()*
                                        *lh#list#find_entity()*
lh#list#contain_entity({list}, {entity})     (1)~
lh#list#not_contain_entity({list}, {entity}) (2)~
lh#list#find_entity({list}, {entity})        (3)~
@param    {list}  |List|
@param  {entity}  |List| or |Dict| to search within the list with |expr-is|.
@return (1) Whether an {entity} is present within {list}
@return (2) Whether an {entity} is NOT present within {list}
@return (3) The index of the {entity} in the {list}, -1 is not found
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            *lh#list#find_if()* *lh#list#Find_if()*           {{{3
                            *lh#list#find_if_fast()*
lh#list#Find_if({list}, {string-predicate} [, {pred-parameters}][, {start-pos}])~
lh#list#find_if({list}, {functor-predicate} [, {pred-parameters}][, {start-pos}])~
lh#list#find_if_fast({list}, {simple-predicate} [, {start-pos}])~
@param             {list}  |List|
@param      {*-predicate}  Predicate to evaluate
@param {pred-parameters}]  |List| of Parameters to bind to special arguments in
                           the {predicate}.
@param         {start-pos} First index to check
@return                    The lowest index, >= {start-pos}, in |List| {list}
                           where the {predicate} evals to true.
@return                    -1 if no item matches {pattern}.
@see |index()|, |eval()|

The {string-predicate} recognizes some special arguments:
- |v:val| is substituted with the current element being evaluated in the list
- *v:1_* *v:2_* , ..., are substituted with the i-th elements from
  {pred-parameters}.
  NB: the "`v:\d\+_`" are 1-indexed while {pred-parameters} is indeed seen as
  0-indexed by Vim.
  This particular feature permits to pass any type of variable to the
  predicate: a |expr-string|, a |List|, a |Dictionary|, ...

The {simple-predicate} only recognizes |v:val| and |v:key| arguments.
`lh#list#find_if_fast()` is something like 100 times faster than
`lh#list#find_if()` on the example below.

e.g.: >
    :let b = { 'min': 12, 'max': 42 }
    :let l = [ 1, 5, 48, 25, 5, 28, 6]
    :let i = lh#list#Find_if(l, 'v:val>v:1_.min  && v:val<v:1_.max && v:val%v:2_==0', [b, 2] )
    :echo l[i]
    28

The {functor-predicate} is a |lhvl#function|. The same example can be
rewritten as: >
    :let l = [ 1, 5, 48, 25, 5, 28, 6]
    :let i = lh#list#find_if(l, 'v:1_>12  && v:1_<42 && v:1_%2==0')
    :let j = lh#list#find_if(l, 'v:val>12  && v:val<42 && v:val%2==0')
    :echo l[i] . ' -- ' . l[j]
    28 -- 28
NB: Expect the `Find_if()` version to be replaced with the `find_if()` one.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        *lh#list#lower_bound()* *lh#list#upper_bound()*   {{{3
                        *lh#list#equal_range()*
lh#list#lower_bound({list}, {value} [, {first}][, {last}])~
lh#list#upper_bound({list}, {value} [, {first}][, {last}])~
lh#list#equal_range({list}, {value} [, {first}][, {last}])~
@param  {list}  Sorted |List|
@param  {value} Value to search
@param  {first} First index to check
@param  {last}  Last+1 index to check
@return The lowest index, >= {first} and < {last}, in |List| {list}
        such as the index is <= first {value} occurrence, in lower_bound case
        such as the index is > last {value} occurrence, in upper_bound case
@return -1 if no item matches {pattern}.
@return the pair `[lower_bound(), upper_bound()]` in `equal_range()` case
@see C++ STL eponym algorithms.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#not_found()*              {{{3
lh#list#not_found({range})~
Returns whether the {range} is empty. This function can be used to check
|lh#list#equal_range()| functions results

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                   *lh#list#unique_sort()* *lh#list#unique_sort2()*  {{{3
lh#list#unique_sort({list} [, {cmp}])~
lh#list#unique_sort2({list} [, {cmp}])~
@param[in] {list} |List| to sort
@param      {cmp} |Funcref| or function name that acts as a compare predicate.
                  It seems to be required in order to not compare number with
                  a lexicographic order (with vim 7.1-156)
@return           A new |List| sorted with no element repeated
@todo support an optional {equal} predicate to use in the /unique/ making
process.

The difference between the two functions is the following:
- `unique_sort()` stores all the elements in a |Dictionary|, then sort the values
  stored in the dictionary ;
- `unique_sort2()` sorts all the elements from the initial |List|, and then
  keeps only the elements that appear once.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                           *lh#list#uniq()*                   {{{3
lh#list#uniq({list})~
@return Emulates |uniq()| when it doesn't exists. Or directly call it
otherwise.
@pre The emulation doesn't support all parameters supported by |uniq()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#Transform()*              {{{3
lh#list#Transform({input},{output},{action})~
@param[in]   {input} Input |List| to transform
@param[out] {output} Output |List| where the transformed elements will be
                     appended.
@param      {action} Stringified action to apply on each element from {input}.
                     The string "`v:val`" will always be replaced with the
                     element currently transformed.
@return {output}

This function is actually returning >
    extend(a:output, map(copy(a:input), a:action))

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#transform()*              {{{3
lh#list#transform({input},{output},{action})~
@param[in]   {input} Input |List| to transform
@param[out] {output} Output |List| where the transformed elements will be
                     appended.
@param      {action} |lhvl#functor| action to apply on each element from
                     {input}.
@return              {output}

This function is equivalent to (|lh#list#Transform()|) >
    extend(a:output, map(copy(a:input), a:action))
except the action is not a string but a |lhvl#functor|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#list#transform_if()*           {{{3
lh#list#transform_if({input},{output},{action},{predicate})~
@param[in]   {input} Input |List| to transform
@param[out] {output} Output |List| where the transformed elements will be
                     appended.
@param      {action}|lhvl#functor| action to apply on each element from
                     {input} that verifies the {predicate}.
@param   {predicate} Boolean |lhvl#functor| tested on each element before
                     transforming it.
@return              {output}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#chain_transform()*        {{{3
lh#list#chain_transform({input},{actions})~
@param[in]    {input} Input |List| to transform
@param[out]  {output} Output |List| where the transformed elements will be
                      appended.
@param      {actions} |lhvl#functor| actions to apply on each element from
                      {input}.
@return               {output}

Example: >
   :let min_sec = [
      \ '3:04', '3:14', '5:38', '4:12', '10:30', '6:29', '6:53', '11:49',
      \ '9:33', '4:17', '7:49', '6:10', '6:04', '6:28', '6:40', '4:21' ]
   :let res = lh#list#accumulate2(
   \   lh#list#chain_transform(
   \      min_sec,
   \      ['split(v:1_, ":")', 'v:1_[0]*60 + v:1_[1]']),
   \   0)
   :AssertEquals (strftime('%H:%M:%S', res), '02:43:11')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#for_each_call()*          {{{3
lh#list#for_each_call({list}, {action})~
@param[in] {list}    |List|
@param[in] {action}  |function| to call of each elements of the {list}
@Return    nothing

Examples: >
    let l = [1,2,3,4,5]
    let g:d = []
    call lh#list#for_each_call(l, 'add(g:d, v:val)')
    AssertEquals(g:d, l)

    let l = ['a', 'b', 'c', 'd']
    let g:d = []
    call lh#list#for_each_call(l, 'add(g:d, v:val)')
    AssertEquals(g:d, l)


    " lh-cpp class-skeleton.template
    VimL: call lh#list#for_each_call(s:parents_data[1], "lh#mut#_add_post_expand_callback(\"lh#dev#import#add(v:val)\")")

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#map_on()*                 {{{3
lh#list#map_on({list}, {index}|{key}, {action})~
@param[in] {list}    |List| of |List|s, or |List| of |Dict|s
@param[in] {index}   Index to be used to extract values in the inner |List|s.
or
@param[in] {key}     Key to be used to extract values in the inner |Dict|s.
@param[in] {action}  |lhvl#functor| action to apply on each element from {list}

@returns of list of the values that are stored:
  - at a given {index} in the lists from the input {list}
  - or at a given {key} in the dictionaries from the input {list}
after |map()| transformation with {action}

Examples: >
    " List of Lists
    let list =
          \ [ [ 0, 'a', 42, [] ]
          \ , [ 1, 'b', 42, 12 ]
          \ , [ 2, 42, 42 ]
          \ , [ 3, 'a', 42 ]
          \ , [ 4, 15, 42 ]
          \ , [ 5, 'c', 42 ]
          \ , [ 6, 'c', 42 ]
          \ , [ 7, 8, 42 ]
          \ ]
    let l0 = lh#list#map_on(deepcopy(list), 0, 'v:val * 2')
    AssertEquals (lh#list#get(l0, 0), map(range(8), 'v:val * 2'))
    AssertEquals (lh#list#get(l0, 1), ['a', 'b', 42, 'a', 15, 'c', 'c', 8])

    let l1 = lh#list#map_on(deepcopy(list), 1, 'strlen(v:val) . "foo"')
    AssertEquals (lh#list#get(l1, 0), range(8))
    AssertEquals (lh#list#get(l1, 1), ['1foo', '1foo', '2foo', '1foo', '2foo', '1foo', '1foo', '1foo'])

    " List of Dicts
    let list =
          \ [ { 'k1': 0, 'k2': 'a'}
          \ , { 'k1': 1, 'k2': 'b'}
          \ , { 'k1': 2, 'k2': 42}
          \ , { 'k1': 3, 'k2': 'a'}
          \ , { 'k1': 4, 'k2': 15}
          \ , { 'k1': 5, 'k2': 'c'}
          \ , { 'k1': 6, 'k2': 'c'}
          \ , { 'k1': 7, 'k2': 8}
          \ ]
    let l0 = lh#list#map_on(deepcopy(list), 'k1', 'v:val * 2')
    AssertEquals (lh#list#get(l0, 'k1'), map(range(8), 'v:val * 2'))
    AssertEquals (lh#list#get(l0, 'k2'), ['a', 'b', 42, 'a', 15, 'c', 'c', 8])

    let l1 = lh#list#map_on(deepcopy(list), 'k2', 'strlen(v:val) . "foo"')
    AssertEquals (lh#list#get(l1, 'k1'), range(8))
    AssertEquals (lh#list#get(l1, 'k2'), ['1foo', '1foo', '2foo', '1foo', '2foo', '1foo', '1foo', '1foo'])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#copy_if()*                {{{3
lh#list#copy_if({input},{output},{predicate})~
Appends in {output} the elements from {input} that verifies the {predicate}.

@param[in]   {input} Input |List| to transform
@param[out] {output} Output |List| where the elements that verify the
                     {predicate} will be appended.
@param   {predicate} Boolean |lhvl#functor| tested on each element.
@return              {output}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#cross()*                  {{{3
lh#list#cross({range1}, {range2}, {func})~
Combines elements from {range1} with elements from {range2} thanks to {func}

@param[in] {range1} Input |List|
@param[in] {range2} Input |List|
@param[in] {func}   Binary function.
                    Can be either a binary functions, or a string where
                    `v:val` represents elements for {range1} and where `l:val2`
                    represents elements from {range2}.
@todo Support |lhvl#functor| in{func}
@since Version 4.0.0
@return    |List| made as a kind of cross product: >
    for val1 in range1
        for val2 in range2
            res += [ Func(val1, val2)]
        endfor
    endfor

This means: >
    let rng1 = [ 'a', 'b', 'c']
    let rng2 = [ 0, 1, 2]

    AssertEquals(lh#list#cross(rng1, rng2, {a, b -> a.b}),
          \ ['a0', 'b0', 'c0', 'a1', 'b1', 'c1', 'a2', 'b2', 'c2'])

    AssertEquals(lh#list#cross(rng2, rng2, {a, b -> a+b}),
          \ [ 0, 1, 2, 1, 2, 3, 2, 3, 4])

    AssertEquals(lh#list#cross(rng1, rng2, 'v:val.l:val2'),
          \ ['a0', 'b0', 'c0', 'a1', 'b1', 'c1', 'a2', 'b2', 'c2'])

    AssertEquals(lh#list#cross(rng2, rng2, 'v:val + l:val2'),
          \ [ 0, 1, 2, 1, 2, 3, 2, 3, 4])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#accumulate()*             {{{3
lh#list#accumulate({input},{transformation[s]},{accumulator})~
Accumulates the transformed elements from {input}.

@param[in]      {input}    Input |List| to transform
@param {transformation[s]} |lhvl#functor|, or list of functors, applied on
                           each element from {input}.
@param    {accumulator}    |lhvl#functor| taking the list of tranformed elements
                           as input
@return                    the result of {accumulator}

Examples: >
   :let strings = [ 'foo', 'bar', 'toto' ]
   :echo eval(lh#list#accumulate(strings, 'strlen', 'join(v:1_,  "+")'))
   10

   :let l = [ 1, 2, 'foo', ['bar']]
   :echo lh#list#accumulate(l, 'string', 'join(v:1_, "##")')

   :let min_sec = [
        \ '3:04', '3:14', '5:38', '4:12', '10:30', '6:29', '6:53', '11:49',
        \ '9:33', '4:17', '7:49', '6:10', '6:04', '6:28', '6:40', '4:21' ]
   :let res = eval(lh#list#accumulate(min_sec,
        \ ['split(v:1_, ":")', 'v:1_[0]*60 + v:1_[1]'], 'join(v:1_,  "+")'))
   :AssertEquals (strftime('%H:%M:%S', res), '02:43:11')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#accumulate2()*            {{{3
lh#list#accumulate2({input},{init}[,{accumulator}])~
Accumulates elements from {input}.

@param[in]      {input} Input |List| to transform
@param[in]       {init} Initial value to accumulate to
@param    {accumulator} |lhvl#functor| adds an element in the accumulated
                        result. Default: add the two elements.
@return                 the result of {accumulator}

Examples: >
   :let llist = [ [1,2], [5,6], [3,4]]
   :echo lh#list#accumulate2(llist, [])
   [1, 2, 5, 6, 3, 4]

   :let strings = [ 'foo', 'bar', 'toto' ]
   :echo lh#list#accumulate2(strings, 0, 'v:1_ + strlen(v:2_)')
   10

   :echo lh#list#accumulate2(llist, [], 'v:2_ + v:1_')
   [3, 4, 5, 6, 1, 2]

   :let l = [1, 2, 5, 6, 3, 4]
   :echo lh#list#accumulate(l, 0)
   21

   :echo lh#list#accumulate(l, 1, 'v:1_ * v:2_')
   720

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                               *lh#list#arg_max()* *lh#list#arg_min()*           {{{3
lh#list#arg_min({list} [, Transfo])~
lh#list#arg_min({list} [, Transfo])~
@since v4.0.0
Returns The arg-minimum, /arg-maximum of a |List| of elements.
If provided, the transformation |function| {Transfo} is applied on each
element before checking which one is greater/lesser of them all.
@see also |lh#float#arg_min()| and |lh#float#arg_max| which are dedicated
|expr-float|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Accumulates elements from {input}.
                                               *lh#list#flatten()*                {{{3
lh#list#flatten({list})~
@param[in] {list} to flatten
@return    list flattened
This function flattens a list >

  let l = [ [[[0]]], 1, 2, [3,4], [5, [6]]]
  AssertEquals(lh#list#flatten(l), range(7))

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#separate()*               {{{3
lh#list#separate(list, pred)~
@param[in] {list} |List| to filter
@param[in] {pred} |Function| predicate  that takes two parameters (element index, and
element value)
@return        An array of two |List|s. The first contains the elements from
               {list} that match the predicate, while the second contains
               those that don't match.
@since Version 3.14.1
@see |filter()|

Examples: >
  let l = [ 1, 5, 48, 25, 5, 28, 6]
  if has('lambda')
    let [min, max] = lh#list#separate(l, {idx, val -> val <10})
    AssertEquals(min, [1, 5, 5, 6])
    AssertEquals(max, [48, 25, 28])
  endif

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#sort()*                   {{{3
lh#list#sort({list} [{options}])~
This function is an encapsulation of |sort()| that fixes the bug where
"`foo bar`" is sorted before "`foo`".
This bug has been fixed in vim version 7.4.411.

It takes the same parameters plus `'N'` option in order to sort numbers
represented as strings. >

    :let l = [ '1', '5', '48', '25', '5', '28', '6']

    " standard behaviour: do nothing
    AssertEquals(sort(copy(l), 'n'), l)

    " lh#list#sort() behaviour: sort as if it was a list of number.
    " the expected result is still list of strings
    :let expected = [ '1', '5', '5', '6', '25', '28', '48']
    let res = lh#list#sort(l, 'N')
    AssertEquals!(res, expected)
    " Assert sorted in place
    AssertIs(l, res)

It can also sort list of lists. This time the sort is done on the first index.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#subset()*                 {{{3
lh#list#subset({input},{indices})~
Returns a subset slice of the {input} list.

@param[in] {input}   Input |List| from which elements will be extracted
@param[in] {indices} |List| of indices to extract
@return a |List| of the elements from {input} indexed by the {indices}
@see also |lh#list#subset()|

Example: >
    :let l = [ 1, 25, 5, 48, 25, 5, 28, 6]
    :let indices = [ 0, 5, 7, 3 ]
    :echo lh#list#subset(l, indices)
    [ 1, 5, 6, 48 ]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#rotate()*                 {{{3
lh#list#rotate({list}, {rot})~
@param[in] {list} Input |List| to rotate
@param[in] {rot}  Number of elements to rotate.
@pre {rot} must belong to `[-len({list}), +len({list})]`
>
    :echo lh#list#rotate([1,2,3,4,5], 1)
    [2, 3, 4, 5, 1]
    :echo lh#list#rotate([1,2,3,4,5], -1)
    [5, 1, 2, 3, 4]
    :echo lh#list#rotate([1,2,3,4,5], -2)
    [4, 5, 1, 2, 3]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#mask()*                   {{{3
lh#list#mask({input},{masks})~
Returns a subset of the {input} list according to a {mask} list.

@param[in] {input} Input |List| from which elements will be extracted
@param[in] {masks} Each elements tells whether the element of same index in
the {input} will be returned.

Example: >
    :let l = [ 1, 25, 5, 48, 25, 5, 28, 6]
    :let masks = [ 1, 0, 0, 1, 0, 1, 0, 1]
    :echo lh#list#mask(l, masks)
    [ 1, 48, 5, 6 ]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#flat_extend()*            {{{3
lh#list#flat_extend(list, rhs)~
@param[in,out] {list} |List| to extend
@param[in]     {rhs}  Element to insert, flattened,  into the list
@return        The {list}
Extends a {list} with another, or add elements into a list depending on the
{rhs} parameter

Examples: >

  let list = [1,2,3]

  AssertEquals(lh#list#flat_extend(copy(list), 5), [1,2,3,5])
  AssertEquals(lh#list#flat_extend(copy(list), [5,6]), [1,2,3,5,6])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#push_if_new()*            {{{3
lh#list#push_if_new(list, value)~
@param[in,out] {list} |List| to extend
@param[in]     {value} Element to insert, if new.
@return        The {list}
Adds an element into a list, if not already present. Unlike
|lh#list#push_if_new_entity()| this function compares values.

Examples: >

  let list = [1,2,3]

  AssertEquals(lh#list#push_if_new(copy(list), 5), [1,2,3,5])
  AssertEquals(lh#list#push_if_new(copy(list), 2), [1,2,3])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#push_if_new_elements()*   {{{3
lh#list#push_if_new_elements(list, values)~
@param[in,out] {list} |List| to extend
@param[in]     {values} Elements to insert, if new.
@return        The {list}
Adds elements into a list, if not already present

Examples: >

  let list = [1,2,3]

  AssertEquals(lh#list#push_if_new_elements(copy(list), [1, 2, 5, 8]), [1,2,3,5,8])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#push_if_new_entity()*     {{{3
lh#list#push_if_new_entity(list, entity)~
@param[in,out] {list} |List| to extend
@param[in]     {entity} Element to insert, if a new entity.
@return        The {list}
Adds an element into a list, if not already present. Unlike
|lh#list#push_if_new()| this function compares entities.
Examples: >

  let e = [1,2,3]
  let list = [ [1,2,3], [4,5], [7,8] ]

  Assert ! lh#list#contain_entity(list, e)
  Assert lh#list#not_contain_entity(list, e)
  AssertEquals(lh#list#find_entity(list, e), -1)

  AssertEquals(lh#list#push_if_new_entity(list, e), [ [1,2,3], [4,5], [7,8], [1,2,3] ])

  Assert lh#list#contain_entity(list, e)
  Assert ! lh#list#not_contain_entity(list, e)
  AssertEquals(lh#list#find_entity(list, e), 3)

  AssertEquals(lh#list#push_if_new_entity(list, e), [ [1,2,3], [4,5], [7,8], [1,2,3] ])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#remove()*                 {{{3
lh#list#remove({input},{indices})~
Returns a subset slice of the {input} list trimmed of elements.

@param[in,out]   {input} |List| from which  element will be removed
@param[in]     {indices} |List| of indices to remove
@return a |List| of the elements from {input} not indexed by the {indices}
@pre {indices} MUST be sorted

Example: >
    :let l = [ 1, 25, 5, 48, 25, 5, 28, 6]
    :let indices = [ 0, 3, 5, 7 ]
    :echo lh#list#remove(l, indices)
    [ 25, 5, 25, 28 ]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#intersect()*              {{{3
lh#list#intersect({list1},{list2})~
Returns the elements present in both input lists.

@param[in] {list1} |List|
@param[in] {list2} |List|
@return a |List| of the elements in both {list1} and {list2}, the elements are
kepts in the same order as in {list1}
@complexity O(len({list1})*len({list2}))
@see also |lh#list#concurrent_for()| which will have a linear complexity of
O(len({list1})+len({list2})).

Example: >
    :let l1 = [ 1, 25, 7, 48, 26, 5, 28, 6]
    :let l2 = [ 3, 8, 7, 25, 6 ]
    :echo lh#list#intersect(l1, l2)
    [ 25, 7, 6 ]

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#is_contained_in()*        {{{3
lh#list#is_contained_in({sublist},{list})~
Returns whether all elements from {sublist} are present in {list}

@param[in] {sublist} |List|
@param[in] {list}    |List|
kepts in the same order as in {list1}
@see also |lh#list#intersect()| upon which this function is built.
@since Version 5.2.2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#list#concurrent_for()*         {{{3
lh#list#concurrent_for({input1}, {intpu2}, {output1}, {output2}, {output0}[, {cmp}])~
@param[in]  {input1}   First input |List|
@param[in]  {input2}   Second input |List|
@param[out] {output1} First output |List|
@param[out] {output2} Second output |List|
@param[out] {output0} Third output |List|
@param[in]  {cmp}      Comparison predicate, or 'n', 'N', nothing (see |lh#list#sort()|)
@pre {input1} and {input2} are expected to be sorted according to {cmp}.
@post {outpu1}, {output2} and {output0} will be sorted according to {cmp}.
@post len({input1})+len({input2}) == len({output1})+len({output2})+len({output3})
@complexity O(len({input1})+len({input2}))
@Return    nothing

This function performs a concurrent for. the two input will be parsed in
ascending order. Elements only present in {input1} will be strored into
{output1}, elements only present in {input2} will be stored into {output2}.
Elements present in both will be stored into {output0}.

C++ `std::set_symetric_difference()` can be emulated with >
    lh#list#concurrent_for(in1, in2, out, out, [], predicate)

C++ `std::set_intersection()` can be emulated with >
    lh#list#concurrent_for(in1, in2, [], [], out, predicate)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#get()*                    {{{3
lh#list#get(list [, key|index [, default_when_absent])~

Mandatory Params:
    @param[in] {list}    |List| of |List|s, or |List| of |Dict|s
    @param[in] {index}   Index to be used to extract values in the inner |List|s.
    or
    @param[in] {key}     Key to be used to extract values in the inner |Dict|s.
Optional param
    @param[in] {default} Default value used when nothing is found at the given
                         {key} or {index}.

@returns of list of the values that are stored:
- at a given {index} in the lists from the input {list}
- or at a given {key} in the dictionaries from the input {list}

This function is a [|map()| |get()|({key}/{index}) {list}].

Examples: >
    " List of Lists
    let list =
          \ [ [ 0, 'a', 42, [] ]
          \ , [ 1, 'b', 42, 12 ]
          \ , [ 2, 42, 42 ]
          \ , [ 3, 'a', 42 ]
          \ , [ 4, 15, 42 ]
          \ , [ 5, 'c', 42 ]
          \ , [ 6, 'c', 42 ]
          \ , [ 7, 8, 42 ]
          \ ]
    AssertEquals (lh#list#get(list, 0), range(8))
    AssertEquals (lh#list#get(list, 1), ['a', 'b', 42, 'a', 15, 'c', 'c', 8])

    " List of Dicts
    let list =
          \ [ { 'k1': 0, 'k2': 'a'}
          \ , { 'k1': 1, 'k2': 'b'}
          \ , { 'k1': 2, 'k2': 42}
          \ , { 'k1': 3, 'k2': 'a'}
          \ , { 'k1': 4, 'k2': 15}
          \ , { 'k1': 5, 'k2': 'c'}
          \ , { 'k1': 6, 'k2': 'c'}
          \ , { 'k1': 7, 'k2': 8}
          \ ]
    AssertEquals (lh#list#get(list, 'k1'), range(8))
    AssertEquals (lh#list#get(list, 'k2'), ['a', 'b', 42, 'a', 15, 'c', 'c', 8])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#possible_values()*        {{{3
lh#list#possible_values(list [, key|index [, default_when_absent])~

Mandatory Param:
    @param[in] {list} Flat |List|, or |List| of |List|s, or |List| of |Dict|s
First Optional param
    @param[in] {index} Index to be used to extract values in the inner |List|s.
    @param[in] {key}   Key to be used to extract values in the inner |Dict|s.
Second Optional param
    @param[in] {default} Default value used when nothing is found at the given
    {key} or {index}. Default value for {default} is |lh#option#unset()|.

@returns of sorted list of the values that are stored in:
- a flat list
- or at a given {index} in the lists from the input {list}
- or at a given {key} in the dictionaries from the input {list}

The two last modes of this function are equivalent to >
    uniq(sort(lh#list#get({list}, {key}|{index})))

Examples: >
    " Flat lists
    let list = [ 'a', 'b', 42, 'a', 15, 'c', 'c', 8]
    Assert lh#list#possible_values(list) == ['a', 'b', 'c', 15, 42, 8]

    " List of Lists
    let list =
          \ [ [ 0, 'a', 42, [] ]
          \ , [ 1, 'b', 42, 12 ]
          \ , [ 2, 42, 42 ]
          \ , [ 3, 'a', 42 ]
          \ , [ 4, 15, 42 ]
          \ , [ 5, 'c', 42 ]
          \ , [ 6, 'c', 42 ]
          \ , [ 7, 8, 42 ]
          \ ]
    AssertEquals (lh#list#possible_values(list, 0), range(8))
    AssertEquals (lh#list#possible_values(list, 1), ['a', 'b', 'c', 15, 42, 8])
    " OK, this ine is odd, but it works!
    AssertEquals (lh#list#possible_values(list, 3), [ 12, [], {}])

    " List of Dicts
    let list =
          \ [ { 'k1': 0, 'k2': 'a'}
          \ , { 'k1': 1, 'k2': 'b'}
          \ , { 'k1': 2, 'k2': 42}
          \ , { 'k1': 3, 'k2': 'a'}
          \ , { 'k1': 4, 'k2': 15}
          \ , { 'k1': 5, 'k2': 'c'}
          \ , { 'k1': 6, 'k2': 'c'}
          \ , { 'k1': 7, 'k2': 8}
          \ ]
    AssertEquals (lh#list#possible_values(list, 'k1'), range(8))
    AssertEquals (lh#list#possible_values(list, 'k2'), ['a', 'b', 'c', 15, 42, 8])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#zip()*                    {{{3
lh#list#zip({list1}, {list2}...)~
@pre all lists shall have the same size.
@since Version 3.10.0
@warning, since version 4.0.0, the behaviour has drastically changed to follow
Python's one.
Zip any number of |List|s into one. >

  let l1 = ['a', 'b', 'c']
  let l2 = [1, 2, 3]
  AssertEquals(lh#list#zip(l1, l2), [['a', 1], ['b', 2], ['c', 3]])
  AssertThrows(lh#list#zip([1], [1,2]))

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#list#zip_as_dict()*            {{{3
lh#list#zip_as_dict({list1}, {list2})~
@pre both lists shall have the same size.
@since Version 3.10.0
Zip two |List|s into a |Dictionary|. >

  let l1 = ['a', 'b', 'c']
  let l2 = [1, 2, 3]
  AssertEquals(lh#list#zip_as_dict(l1, l2), {'a': 1, 'b': 2, 'c': 3})
  AssertThrows(lh#list#zip_as_dict([1], [1,2]))

------------------------------------------------------------------------------
DICT RELATED FUNCTIONS                                *lhvl#dict*       {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#add_new()*                {{{3
lh#dict#add_new(dict1, dict2)~
@param[in,out] {dict1} |Dict| to extend
@param[in]     {dict2} Element to insert, if new.
@return        The {dict1}
Adds an element into a dictionary if not already present
@note This is just a wrapper around |extend()|.

Examples: >

  let d1 = {'k1': 1, 'k2': 2}

  AssertEquals(lh#dict#add_new(copy(d1), {'k3': 'trois', 'k4': 'quatre'}),
                                       \ {'k1': 1, 'k2': 2, 'k3': 'trois', 'k4': 'quatre'})
  AssertEquals(lh#dict#add_new(copy(d1), {'k3': 'trois', 'k1': 'un'}),
                                       \ {'k1': 1, 'k2': 2, 'k3': 'trois'})

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#get_composed()*           {{{3
lh#dict#get_composed(dict, keys [, default])~
@param[in] {dict}    |Dict| to poke
@param[in] {keys}    Composition of keys
@param[in] {default} Default value return instead of |lh#option#unset()| in
                     case the variable doesn't exist.
@return `{dict}[keys]`

Examples: >

  LetTo g:foo.bar.team = 12

  AssertEquals(lh#dict#get_composed(g:, 'foo.bar.team'), 12)
  AssertEquals(lh#dict#get_composed(g:foo,  'bar.team'), 12)
  AssertEquals(lh#dict#get_composed(g:foo.bar,  'team'), 12)
  AssertThrows lh#dict#get_composed(g:foo, 'beer.team')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#key()*                    {{{3
lh#dict#key(one_key_dict)~
@param[in]     {one_key_dict} Dictionary to test
@return        The first element of the dictionary
@throw         An exception if the dictionary has more than one element.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#let()*                    {{{3
lh#dict#let(dict, keys, value)~
@param[in] {dict}  |Dictionary| that'll be modified
@param[in] {keys}  |expr-string| of dot separated list of dictionary subkeys.
                   `{k1}.{k2}....{kn}`
@param[in] {value} Value to assign at `{dict}[{k1}][{k2}]...[{kn}]`
@return    `{dict}[{k1}]`
@throw     None
@see also |lh#dict#need_ref_on()|

Makes sure `{dict}[{k1}][{k2}]...[{kn}] == {value}`

Important: it may change the type of an already existing value associatiated
to an intermediairy subkey to |dictionary|, i.e. the following works >
    let d = {'a': {'b': 1}}
    call lh#dict#let(d, 'a.b.c.d.e', 42)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#print_as_tree()*          {{{3
lh#dict#print_as_tree(dict)~
@since Version 4.7.1

Pretty printer for |dictionaries|. Present them as trees
e.g. >
    echo lh#dict#print_as_tree({'a': 12, 'b': 15, 'c':[['{', 'toto'], 1], 'd':
    \ { 'foo': 'bar', 1: 'too', 5: 'titi', 6: {42: 'last'}}})

will display: >
    {
    +- 'a' = 12
    +- 'b' = 15
    +- 'c' = [
            +- 0 -> [
                    +- 0 -> '{'
                    +- 1 -> 'toto'
                    ]
            +- 1 -> 1
            ]
    +- 'd' = {
            +- 'foo' = 'bar'
            +- '1'   = 'too'
            +- '5'   = 'titi'
            +- '6'   = {
                    +- '42' = 'last'
                    }
            }
    }

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#need_ref_on()*            {{{3
lh#dict#need_ref_on(root, keys [, last_default])~
@param[in] {root}           Root |dictionary| that'll be modified
@param[in] {keys}           |expr-string| of dot separated list of dictionary subkeys
                            `{k1}.{k2}....{kn}`, or |list| of subkeys
@param[in] [{last_default}] Value to assign at `{dict}[{k1}][{k2}]...[{kn}]`,
                            use `{}` is not specified.
@return    `{dict}[{k1}][{k2}]...[{kn}]`
@throw     None
@pre       It won't change the type of an already existing value associatiated
           to an intermediairy subkey to |dictionary|, i.e. the following
           crashes >
                let d = {'a': {'b': 1}}
                call lh#dict#need_ref_on(d, 'a.b.c.d.e', 42)
@see also |lh#dict#let()|
@since Version 4.5.0
@note subkeys are added on the fly
@note it'll be best for {last_default} to be either a |dictionary| or a |list|
otherwise, the result won't be a reference

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#dict#subset()*                 {{{3
lh#dict#subset({input},{keys})~
Returns a subset slice of the {input} dict.

@param[in] {input}  Input |Dict| from which elements will be extracted
@param[in] {keys}   |List| of keys to extract
@return a |Dict| of the elements from {input} indexed by the {keys}.
@see also |lh#list#subset()|

Example: >
    :let d = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}
    :let keys = [ 'a', 'c', 'd']
    :echo s = lh#dict#subset(d, keys)
    {'a':1, 'c':3, 'd':4}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

------------------------------------------------------------------------------
GRAPH RELATED FUNCTIONS                               *lhvl#graph*      {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#graph#tsort#depth()*             {{{3
                                             *lh#graph#tsort#breadth()*           {{{3
lh#graph#tsort#depth({dag}, {start-nodes})~
lh#graph#tsort#breadth({dag}, {start-nodes})~
These two functions implement a topological sort on the Direct Acyclic Graph.
- `depth()` is a recursive implementation of a depth-first search.
- `breadth()` is a non recursive implementation of a breadth-first search.

@param {dag} is a direct acyclic graph defined either:
             - as a |Dictionnary| that associates to each node, the |List| of
               all its successors
             - or as a /fetch/ |function()| that returns the |List| of the
               successors of a given node -- works only with depth() which
               takes care of not calling this function more than once for each
               given node.
@param {start-nodes} is a |List| of start nodes with no incoming edge
@throw "`Tsort: cyclic graph detected:`" if {dag} is not a DAG.
@see http://en.wikipedia.org/wiki/Topological_sort
@since Version 2.1.0
@test tests/lh/topological-sort.vim

------------------------------------------------------------------------------
PATH RELATED FUNCTIONS                                *lhvl#path*       {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                    *lh#path#add_path_if_exists()*     {{{3
lh#path#add_path_if_exists(listname, path)~
@param[in,out] {lisname} |List| of pathnames to complete, or |p:var|iable that
                         designates a |List|.
@param[in]     {path}    a pathname
@return Nothing
@see also |lh#path#munge()|

The {path} may end in `/**` which will be ignored.
If {path} is a directory, it'll be added to {listname}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                    *lh#path#cd_without_sideeffects()* {{{3
lh#path#cd_without_sideeffects({pathname})~
According to |haslocaldir()|, this function will perform either a |:cd|, or a
|:lcd|.
@param[in] {pathname} that is expected to exist.
@see also |lh#os#lcd()|
@since Version 4.0.0

In order to change the current directory, it's important to take the context
into account. Indeed:
- unconditional use to |:lcd| will set a local directory to the current
  window while there was none
- unconditional use of |:cd| will remove the local directory in all windows
  with a local directory equal to the one of the current window before the
  call to |:cd|.

Thanks to this function, no side effect will be observed.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                    *lh#path#common()*                 {{{3
lh#path#common({pathnames})~
@param[in] {pathnames} |List| of pathnames to analyse
@return the common leading path between all {pathnames}

e.g.: >
 :echo lh#path#common(['foo/bar/file','foo/file', 'foo/foo/file'])
echoes >
 foo/

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                   *lh#path#depth()*                  {{{3
lh#path#depth({dirname})~
Returns the depth of a directory name.

@param {dirname}  Pathname to simplify
@return the depth of the simplified directory name, i.e.
        `lh#path#depth("bar/b2/../../foo/")` returns 1

@todo However, it is not able to return depth of negative paths like
      "`../../foo/`". I still need to decide whether the function should return
      -1 or 3.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                   *lh#path#exe()*                    {{{3
lh#path#exexe({pathname})~
@return the full path of an executable
@since Version 4.6.1

Emulates |exepath()| on old Vim versions

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                   *lh#path#exists()*                 {{{3
lh#path#exists({pathname})~
@return whether {pathname} can be read (with |filereadable|) or whether a
buffer exists with that name (see |bufexists()|).
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                    *lh#path#find()*                   {{{3
lh#path#find({pathslist}, {regex})~
@param[in] {pathslist} List of paths which can be received as a |List| or as a
                       string made of coma separated paths.
@return the path that matches the given {regex}

e.g.: >
 let expected_win = $HOME . '/vimfiles'
 let expected_nix = $HOME . '/.vim'
 let what =  lh#path#to_regex($HOME.'/').'\(vimfiles\|.vim\)'
 let z = lh#path#find(&rtp,what)
 if has('win16')||has('win32')||has('win64')
   Assert z == expected_win
 else
   Assert z == expected_nix
 endif

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                    *lh#path#find_in_parents()*        {{{3
lh#path#find_in_parents({path}, {path-patterns}, {kinds}, {last-valid-path})~
Internal recursive function used by |local_vimrc|.

@param[in]            {path} Current path being analysed.
@param[in]   {path-patterns} Single (|expr-string|) or |List| of filename(s) or
                             dirname to search.
@param[in]           {kinds} What is looked for. Could be `'file'`, `'dir'` or `'file,dir'`.
@param[in] {last-valid-path} |regex| used to stop the recursion. Typical
                             value: `!empty(s:home) ? ('^'.s:home.'$') : ''`

@return a |List| of pathname to file and/or directories that match
{path-patterns} up to {last-valid-path}.
@see also |lh#path#find_upward()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                    *lh#path#find_upward()*            {{{3
lh#path#find_upward({what} [, {from}])~
Encapsulates and upward saerch with |finddir()| or |findfile()|. The exact
function called will depend on the presence of a trailing slash at the end of
{what}.

@param[in] {what} File or directory searched.
@param[in] {from} Where the search starts from. Default: directory of the
                  current file: `expand('%:p:h')`.
@returns the directory where {what} is found, and an empty string if nothing
is found.

@pre {what} shall not be empty
@pre {from} shall not be a distant filename (e.g. `scp://log@host:path/name`)
nor a scratch filename.
@see also |lh#path#find_in_parents()|

@example >
    LetIfUndef g:lh#project.root_patterns = ['.git/', '.svn/', '.hg/', '_darcs/', '.bzr/']
    let possible_prj_dirnames = map(copy(g:lh#project.root_patterns),
    \ '[v:val, lh#path#find_upward(v:val)]')
    call filter(possible_prj_dirnames, '!empty(v:val[1])')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#fix()*                    {{{3
lh#path#fix({pathname} [,{shellslash} [,{quote-char}]]~
Discl.: This function is the old |system-tools|' |FixPathName| moved to lh-vim-lib.

This function corrects the {a:pathname} passed in parameter and, returns the
newly fixed pathname that will be usable will external tools.

Under Windows boxes, it will build the new path according to the value of
{shellslash}. Under other systems, the new path will be exclusively composed of
forward slashes. According to {quote-char}, quote characters may be added around
the returned pathname.

For instance, paths like "`c:\Program Files/alongpath/some\ spaces/foo`" will be
changed into: >
    c:\Program Files\alongpath\some spaces\foo   + {quote-char} around
 or c:/Program\ Files/alongpath/some\ spaces/foo + {quote-char} around
according to {shellslash} value.

Internal considerations~
    {quote-char} will value the character:
        1- {a:quote-char} if given,
        2- "" (empty string) otherwise.
    {shellslash} will value the boolean:
        1- {a:shellslash} if given
        2- 'shellslash' if win16, win32, dos16 or dos32
                    and if |SystemDetected()| != "msdos"
        3- 1 if |SystemDetected()| == "unix"
    if {quote-char}=="" && !{shellslash} && |SystemDetected()|=="`msdos`"
        if 'shell' == "`command.com`" => {quote-char} <- ''
        else                        => {quote-char} <- '"'

Note: If you are using "`command.com`" (and not cmd.exe which is available on
MsWindows NT series), you may run into troubles if the {a:pathname} contains
spaces.

Exemples~
    This mapping opens the current file in MsWindows's files explorer
    [Note: this works if the 'shell' is bash or $COMSPEC]: >
        nmap ,view :exe '!start explorer '.lh#path#fix(expand('%:p'),0)<cr>

Note: Unlike |fnameescape()|, |lh#path#fix()| will work even under the Windows native flavour of gvim, whichever the |'shellslash'| is, and whichever the |'shell'| is.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#glob_as_list()*           {{{3
                                                *lh#path#GlobAsList()*
lh#path#glob_as_list({pathslist}, {expr} [,{must_sort}])~
lh#path#GlobAsList({pathslist}, {expr})  (*deprecated*)~
@param[in] {pathslist} list (|List|, or comma separated list) of paths where
                       to search.
@param[in] {expr}      glob expression of the files to search.
@param[in] {mustSort}  tells whether the results shall be sorted per
                     {pathslist}, default: true.
@return |globpath()|'s result, but formatted as a list of matching pathnames.
In case {expr} is a |List|, |globpath()| is applied on each expression in
{expr}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#is_absolute_path()*       {{{3
lh#path#is_absolute_path({path})~
                                                *lh#path#IsAbsolutePath()*
lh#path#IsAbsolutePath({path})  (*deprecated*)~
@param[in] {path} Path to test
@return whether the path is an absolute path
@note Supports Unix absolute paths, Windows absolute paths, and UNC paths

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#is_distant_or_scratch()*  {{{3
lh#path#is_distant_or_scratch({path})~
@param[in] {path} Path to test
@return
- whether the path is an URL or a name for a scratch buffer (according to
  recent conventions), i.e. whether it contains `"://"`,
- or whether it's an UNC path, i.e. starting with either `"//"` or `"\\"`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#is_in()*                  {{{3
lh#path#is_in({file}, {path})~
Tells whether a {file} is within a directory tree.
The function first tries to check whether the names match, then it tries again
but on resolved pathnames (with |lh#path#readlink()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#is_up_to_date()*          {{{3
lh#path#is_up_to_date({file1}, {file2})~
@param[in] {file1} filename
@param[in] {file2} filename
@return whether |getftime()| of {file1} is lesser than or equal to the one of
{file2}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#is_url()*                 {{{3
lh#path#is_url({path})~
                                                *lh#path#IsURL()*
lh#path#IsURL({path})  (*deprecated*)~
@param[in] {path} Path to test
@return whether the path is an URL
@note Supports http(s)://, (s)ftp://, dav://, fetch://, file://, rcp://,
rsynch://, scp://

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#join()*                   {{{3
lh#path#join({pathparts} [, {path-separator}])~
@param[in] {pathparts} Parts to pathanme to join
@param[in] {path-separator} Joining character to use. Default depends on |'shellslash'|
Join pathname parts
@see also |lh#path#split()|
i.e. >
    AssertEquals(lh#path#join([ "home", "me", "foo", "bar" ]), "home/me/foo/bar")

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#new_permission_lists()*   {{{3
                                                *lhvl#permission-list*
lh#path#new_permission_lists(options)~
Prepares a permission lists object.
@param[in] {options} |Dictionary| made of the |List|s:
  - `"whitelist"`:    |List| of paths always accepted.
  - `"blacklist"`:    |List| of paths always rejected.
  - `"asklist"`:      |List| of paths that needs interactive approval.
  - `"sandboxlist"`:  |List| of paths approved, in the |sandbox| only.
  - `"_do_handle()"`: |Function| executed of approved file,
                    required only by |handle_file()| and |handle_paths()|.
  - `"_action_name"`: Name of the action to display in messages.
@return An object completed with the methods:
  - *prepare()*          -- internal
  - *handle_paths()*     -- applies `"_do_handle()"` to files compatibles with permissions
  - *handle_file()*      -- internal
  - *check_paths()*      -- tells whether a file is compatible with current permissions
  - *is_file_accepted()* -- internal
@since v4.0.0
@see |local_vimrc| documentation for more details.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#readlink()*               {{{3
lh#path#readlink({pathname})~
Resolves any symbolic links in {pathname}.
@param[in] pathname to resolve

Depending on the available external commands, it tries to return:
- `greadlink` exists: ` greadlink -f {pathname}`
- `readlink`  exists: ` readlink  -f {pathname}` -- except on osx
- `realpath`  exists: ` realpath     {pathname}`
- otherwise          `resolve({pathname})`, see |resolve()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#relative_to()*            {{{3
lh#path#relative_to({from}, {to})~
Returns the relative directory that indentifies {to} from {from} location.
@param {from} origin directory
@param {to}   destination directory
@return the simplified pathname {to} in its relative form as it would be seen
        from the {from} directory.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#path#remove_dir_mark()*        {{{3
lh#path#remove_dir_mark({dirname})~
Remove the trailing 'shellslash' character ('`/`' or a '`\`') from {dirname}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#select_one()*             {{{3
                                                *lh#path#SelectOne()*
lh#path#select_one({pathnames},{prompt})~
lh#path#SelectOne({pathnames},{prompt})  (*deprecated*)~
@param[in] {pathnames} |List| of pathname
@param     {prompt}     Prompt for the dialog box

@return "" if len({pathnames}) == 0
@return {pathnames}[0] if len({pathnames}) == 1
@return the selected pathname otherwise

Asks the end-user to choose a pathname among a list of pathnames.
The pathnames displayed will be simplified thanks to |lh#path#strip_common()|
-- the pathname returned is the "full" original pathname matching the
simplified pathname selected.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#shellslash()*             {{{3
lh#path#shellslash()~
@return `'/'` or `'\'` depending on the current OS, or on |'ssl'| state.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#simplify()*               {{{3
                                                *lh#path#Simplify()*
lh#path#simplify({pathname} [{make_relative_to_pwd])~
lh#path#Simplify({pathname})  (*deprecated*)~
Simplifies a path by getting rid of useless '../' and './'.

@param {pathname}             Pathname to simplify
@param {make_relative_to_pwd} The {pathname} is made relative to pwd when set
@return the simplified pathname

This function works like |simplify()|, except that it also strips the leading
"`./`".

Note: when vim is compiled for unix, it seems unable to |simplify()| paths
containing "`..\`". (It likelly works this way when vim is compiled without
'shellslash' support)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#split()*                  {{{3
lh#path#split({path})~
@param[in] {path} Path to split at `[/\\]`
Split pathname parts
@see also |lh#path#join()|
i.e. >
    AssertEquals(lh#path#split("/home/me/foo/bar"), [ "home", "me", "foo", "bar" ])

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#strip_common()*           {{{3
                                                *lh#path#StripCommon()*
lh#path#strip_common({pathnames})~
lh#path#StripCommon({pathnames})  (*deprecated*)~
@param[in,out] {pathnames} |List| of pathnames to simplify
@return the simplified pathnames

This function strips all pathnames from their common leading part. The
compuation of the common leading part is ensured by |lh#path#common()|
thank.
e.g.: >
 :echo lh#path#strip_common(['foo/bar/file','foo/file', 'foo/foo/file'])
echoes >
 ['bar/file','file', 'foo/file']

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#path#strip_start()*            {{{3
                                                 *lh#path#StripStart()*
lh#path#strip_start({pathname}, {pathslist})~
lh#path#StripStart({pathname}, {pathslist})  (*deprecated*)~
@param[in] {pathname}  name to simplify
@param[in] {pathslist} list of pathname (can be a |string| of pathnames
                       separated by "`,`", of a |List|).

Strips {pathname} from any path from {pathslist}.

e.g.: >
 :echo lh#path#strip_start($HOME.'/.vim/template/bar.template',
   \ ['/home/foo/.vim', '/usr/local/share/vim/'])
 :echo lh#path#strip_start($HOME.'/.vim/template/bar.template',&rtp)
echoes >
 template/bar.template

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#path#to_dirname()*             {{{3
lh#path#to_dirname({dirname})~
Ensures the returned directory name ends with a '`/`' or a '`\`'.

@todo On windows, it should take 'shellslash' into account to decide the
      character to append.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#to_relative()*            {{{3
                                                *lh#path#ToRelative()*
lh#path#to_relative({pathname})~
lh#path#ToRelative({pathname})  (*deprecated*)~
@param {pathname} Pathname to convert
@return the simplified {pathname} in its relative form as it would be seen
        from the current directory.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#to_regex()*               {{{3
lh#path#to_regex({pathname})~
Transforms the {pathname} to separate each node-name by the string '`[/\\]`'

The rationale behind this function is to build system independant regex
pattern to use on pathnames as sometimes pathnames are built by appending
'`/stuff/like/this`' without taking 'shellslash' into account.

e.g.: >
 echo lh#path#to_regex('/home/luc/').'\(vimfiles\|.vim\)'
echoes >
 [/\\]home[/\\]luc[/\\]\(vimfiles\|.vim\)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#vimfiles()*               {{{3
lh#path#vimfiles()~
Function that I use to find either `$HOME/.vim/` or the equivalent on windows.
This function got a very internal and personal variation point: if `$LUCHOME`
exists, it's used instead of `$HOME` -- In the past, I've been given access to
shared accounts where my real `$HOME` was something like `$HOME/luc/`...

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#path#writable()*               {{{3
lh#path#writable({pathname})~
@since Version 4.6.0
@return whether {pathname} is writable. If the file doesn't exist, unlike
|filewritable()|, this function checks whether we could write in the parent
directory.

------------------------------------------------------------------------------
MENU RELATED FUNCTIONS                                *lhvl#menu*       {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#menu#def_string_item()*          {{{3
lh#menu#def_string_item({Data})~
@param[in,out] {Data} Definition of a |menu| item.

This function defines a |menu| entry that will be associated to a
|global-variable| whose values can be seen in, and updated, from the menu.

{Data} is a |Dictionary| whose keys are:
- "`variable`": name of the |global-variable| to bind to the menu entry
  Mandatory.
- "`values`": default associated value.
  Optional.
- "`menu`": describes where the menu entry must be placed (|Dictionary|)
    - "`priority`": complete priority of the entry (see |sub-menu-priority|)
    - "`name`": complete name of the entry -- ampersand (&) can be used to define
      shortcut keys
  Mandatory.
- "`hook`": |function| to call, or command to |:execute| when the value of the
  variable is toggled through toggle-menu ; default: none.
- "`actions`": list of functions to call, or commands to execute when the value
  of the variable is toggled through toggle-menu. There shall be one action
  per possible value when defined ; default: empty list

Warning:
    If the variable is changed by hand without using the menu, then the menu
    and the variable will be out of synch. Unless the command |lhvl-:Set|
    is used to change the value of the options (and keep the menu
    synchronized).

Examples:
   See tests/lh/test-toggle-menu.vim

                                                            *lhvl-:Set*
:Set {variable-name} {text-value}~
@param {variable-name}
            must be a |global-variable| name used as "variable" in the
            definition of a string menu item thanks to
            |lh#menu#def_string_item()|.
@param {text-value}
            `:Set` directly sets the variable to the value associated to
            {text-value}.

This command supports autocompletion on the {variable-name}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                             *lh#menu#def_toggle_item()*          {{{3
lh#menu#def_toggle_item({Data})~
@param[in,out] {Data} Definition of a |menu| item.

This function defines a |menu| entry that will be associated to a
|global-variable| whose values can be cycled and explored from the menu. This
global variable can be seen as an enumerate whose value can be cyclically
updated through a menu.

{Data} is a |Dictionary| whose keys are:
- "`variable`": name of the |global-variable| to bind to the menu entry
  Mandatory.
- "`values`": associated values of string or integers (|List|)
  Mandatory.
- "`menu`": describes where the menu entry must be placed (|Dictionary|)
    - "`priority`": complete priority of the entry (see |sub-menu-priority|)
    - "`name`": complete name of the entry -- ampersand (&) can be used to define
      shortcut keys
  Mandatory.
- "`idx_crt_value`": index of the current value for the option (|expr-number|)
  This is also an internal variable that will be automatically updated to
  keep the index of the current value of the "`variable`" in "`values`".
  Optional ; default value is 1, or the associated index of the initial value
  of the variable (in "`values`") before the function call.
- "`texts`": texts to display according to the variable value (|List|)
  Optional, "`values`" will be used by default. This option is to be used to
  distinguish the short encoded value, from the long self explanatory name.
- "`hook`": |function| to call, or command to |:execute| when the value of the
  variable is toggled through toggle-menu ; default: none.
- "`actions`": list of functions to call, or commands to execute when the value
  of the variable is toggled through toggle-menu. There shall be one action
  per possible value when defined ; default: empty list

Warning:
    If the variable is changed by hand without using the menu, then the menu
    and the variable will be out of synch. Unless the command |lhvl-:Toggle|
    is used to change the value of the options (and keep the menu
    synchronized).

Examples:
   See tests/lh/test-toggle-menu.vim

See also |lh#project#menu#def_toggle_item()|.

                                                            *lhvl-:Toggle*
:Toggle {variable-name} [{text-value}]~
@param {variable-name}
            must be a |global-variable| name used as "`variable`" in the
            definition of a toggable menu item thanks to
            |lh#menu#def_toggle_item()|.
@param {text-value}
            when specified, `:Toggle` directly sets the variable to the value
            associated to {text-value}.

This command supports autocompletion on the {variable-name}, and on
{text-value}.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                      *lh#menu#text()*            {{{3
lh#menu#text({text})~
@param[in] {text} Text to send to |:menu| commands
@return a text to be used in menus where "`\`" and spaces have been escaped.

This helper function transforms a regular text into a text that can be
directly used with |:menu| commands.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                      *lh#menu#make()*            {{{3
option: *[gb]:want_buffermenu_or_global_disable*
If Michael Geddes's |buffer-menu| plugin is installed, this option tells
whether we want to take advantage of it to define menus or to ignore it.

lh#menu#make({modes}, {menu-priority}, {menu-text}, {key-binding}, [<buffer>,]  {action})~
Creates a menu entry and its associated mappings for several modes at once.

@param[in] {modes} Vim modes the menus and maps will be provided for
@param[in] {menu-priority} |sub-menu-priority| for the new menu entry
@param[in] {menu-text}      Name of the new menu entry
@param[in] {key-binding}    Sequence of keys to execute the associated action
                            If empty, no mapping will be done.
                            It can be a key to help fill a menu reminder, and
                            yet not define a mapping, it that case it takes
                            the attributes:
            - `'binding'`: what {key-binding} would have contained otherwise
            - `'modes'`:   (not yet implemented)
            - `'action'`:  (not yet implemented)
@param[in] "<buffer>"       If the string "<buffer>" is provided, then the
                            associated mapping will be a |map-<buffer>|, and
                            the menu will be available to the current buffer
                            only. See |[gb]:want_buffermenu_or_global_disable|
                            When "<buffer>" is set, the call to `lh#menu#make()`
                            must be done in the buffer-zone from a |ftplugin|,
                            or from a |local_vimrc|.
@param[in] {action}         Action to execute when {key-binding} is typed, or
                            when the menu entry is selected.

First example:~
The following call will add the menu "LaTeX.Run LaTeX once <C-L><C-O>", with
the priority (placement) 50.305, for the NORMAL, INSERT and COMMAND modes. The
action associated first saves all the changed buffers and then invokes LaTeX.
The same action is also binded to <C-L><C-O> for the same modes, with the
nuance that the maps will be local to the buffer.
>
  call lh#menu#make("nic", '50.305', '&LaTeX.Run LaTeX &once', "<C-L><C-O>",
          \ '<buffer>', ":wa<CR>:call TKMakeDVIfile(1)<CR>")

Second example:~
This example demonstrates an hidden, but useful, behavior: if the mode is the
visual one, then the register v is filled with the text of the visual area.
This text can then be used in the function called. Here, it will be proposed
as a default name for the section to insert:
>
  function! TKinsertSec()
    " ...
    if (strlen(@v) != 0) && (visualmode() == 'v')
      let SecName = input("name of ".SecType.": ", @v)
    else
      let SecName = input("name of ".SecType.": ")
    endif
    " ...
  endfunction

  call lh#menu#make("vnic", '50.360.100', '&LaTeX.&Insert.&Section',
          \ "<C-L><C-S>", '<buffer>', ":call TKinsertSec()<CR>")

We have to be cautious to one little thing, there is a side effect: the visual
mode vanishes when we enter the function. If you don't want this to happen,
use the non-existant command: |:VCall|.

Third example:~
If it is known that a function will be called only under |VISUAL-mode|, and
that we don't want of the previous behavior, we can explicitly invoke the
function with |:VCall| -- command that doesn't actually exist. Check
lh-tex/ftplugin/tex/tex-set.vim |s:MapMenu4Env| for such an example.

Fourth thing: actually, lh#menu#make() is not restricted to commands. The
action can be anything that could come at the right hand side of any |:map| or
|:menu| action. But this time, you have to be cautious with the modes you
dedicate your map to. I won't give any related example ; this is the
underlying approach in |lh#menu#IVN_make()|.


                                                    *lh#menu#make()_modes*
Implementation details:~
The actual creation of the mappings is delegated to |lh#menu#map_all()|.
If the {action} to execute doesn't start with ':', it is left untransformed,
otherwise it is adapted depending on each {mode}:
- INSERT-mode: each recognized |:command| call is prepended with |i_CTRL-O|
- NORMAL-mode: the {action} is used as it is
- VISUAL-mode: ":Vcall" is replaced by "\<cr>gV", otherwise the selection is
  recorded into @v register, the {action} command is executed after a
  |v_CTRL-C|, and eventually @v is cleared.
  The use is @v is deprecated, rely instead on |lh#menu#is_in_visual_mode()|
  and on |lh#selection#visual()|.
- COMMAND-mode: the {action} is prepended with |c_CTRL-C|.

Examples:
   See tests/lh/test-menu-map.vim

See also |lh#project#menu#make()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                      *lh#menu#remove()*          {{{3
lh#menu#remove({modes}, {menu-text})~
Applies |unmenu| as many times as required to remove the menu from the modes
specified.

See also |lh#project#menu#remove()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                  *lh#menu#IVN_make()*        {{{3
Mappings & menus inserting text~
lh#menu#IVN_make(<priority>, {text}, {key}, {IM-action}, {VM-action}, {NM-action} [, {nore-IM}, {nore-VM}, {nore-NM}])~

`lh#menu#IVN_MenuMake()` accepts three different actions for the three modes:
INSERT, VISUAL and NORMAL. The mappings defined will be relative to the
current buffer -- this function is addressed to ftplugins writers. The last
arguments specify whether the inner mappings and abbreviations embedded within
the actions should be expanded or not ; i.e. are we defining
?noremaps/noremenus? ?

You will find very simple examples of what could be done at the end of
menu-map.vim. Instead, I'll show here an extract of my TeX ftplugin: it
defines complex functions that will help to define very simply the different
mappings I use. You could find another variation on this theme in
ftplugin/html/html_set.vim.

>
  :MapMenu 50.370.300 &LaTeX.&Fonts.&Emphasize ]em emph
  call <SID>MapMenu4Env("50.370.200", '&LaTeX.&Environments.&itemize',
        \ ']ei', 'itemize', '\item ')


The first command binds ]em to \emph{} for the three different modes. In
INSERT mode, the cursor is positioned between the curly brackets, and a marker
is added after the closing bracket -- cf. my bracketing system. In VISUAL
mode, the curly brackets are added around the visual area. In NORMAL mode, the
area is considered to be the current word.

The second call binds for the three modes: `]ei` to:
>
      \begin{itemize}
          \item
      \end{itemize}

The definition of the different functions and commands involved just follows.
>
  command -nargs=1 -buffer MapMenu :call <SID>MapMenu(<f-args>)

  function! s:MapMenu(code,text,binding, tex_cmd, ...)
    let _2visual = (a:0 > 0) ? a:1 : "viw"
    " If the tex_cmd starts with an alphabetic character, then suppose the
    " command must begin with a '\'.
    let texc = ((a:tex_cmd[0] =~ '\a') ? '\' : "") . a:tex_cmd
    call lh#menu#IVN_make(a:code, a:text.'     --  ' . texc .'{}', a:binding,
          \ texc.'{',
          \ '<ESC>`>a}<ESC>`<i' . texc . '{<ESC>%l',
          \ ( (_2visual=='0') ? "" : _2visual.a:binding),
          \ 0, 1, 0)
  endfunction

  " a function and its map to close a "}", and that works whatever the
  " activation states of the brackets and marking features are.
  function! s:Close()
    if strlen(maparg('{')) == 0                    | exe "normal a} \<esc>"
    elseif lh#brackets#usemarks()                  | exe "normal ?jump! "
    else                                           | exe "normal a "
    endif
  endfunction

  imap <buffer> ?close! <c-o>:call <SID>Close()<cr>

  function! s:MapMenu4Env(code,text,binding, tex_env, middle, ...)
    let _2visual = (a:0 > 0) ? a:1 : "vip"
    let b = "'" . '\begin{' . a:tex_env . '}' . "'"
    let e = "'" . '\end{' . a:tex_env . '}' . "'"
    call IVN_MenuMake(a:code, a:text, a:binding,
          \ '\begin{'.a:tex_env.'?close!<CR>'.a:middle.' <CR>\end{'.a:tex_env.'}<C-F><esc>ks',
          \ ':VCall MapAroundVisualLines('.b. ',' .e.',1,1)',
          \ _2visual.a:binding,
          \ 0, 1, 0)
  endfunction

Examples:
   See tests/lh/test-menu-map.vim


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                         *lh#menu#is_in_visual_mode()*            {{{3
lh#menu#is_in_visual_mode()~
@return a boolean that tells whether the {action} used in
|lh#menu#is_in_visual_mode()| has been invoked from the VISUAL-mode.

NB: this function deprecates the test on `@v`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                   *lh#menu#map_all()*         {{{3
lh#menu#map_all({map-type}[, {map-args...}])~
This function is a helper function that defines several mappings at once as
|:amenu| would do.

@param {map-type}     String of the form "`[aincv]*(nore)?map`" that tells the
                      mode on which mappings should be defined, and whether
                      the mappings shall be |:noremap|.
@param {map-args...}  Rest of the parameters that defines the mapping


The action to execute will be corrected depending on the current mode. See
|lh#menu#make()_modes| for more details.

------------------------------------------------------------------------------
COMMAND RELATED FUNCTIONS                             *lhvl#command*    {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#analyse_args()*              {{{3
lh#command#analyse_args(a:ArgLead, a:CmdLine, a:CursorPos)~
Helper function to define |:command-completion-custom| functions.
It parses the function parameters to return a |List| of:
" - the position of the token where the cursor is
" - all the tokens up to cursor position

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#matching_variables()*        {{{3
lh#command#matching_variables(lead [, scopes=all])~
Helper function to define |:command-completion-custom| functions.
Returns a list of variables matching the {lead}. Supported variables are:
|g:var|, |b:var|, |t:var|, |w:var|,  |expr-env|ironment variables, |options|.
|p:var| are not supported (yet).

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#matching_for_command()*      {{{3
lh#command#matching_for_command(lead)~
Helper function to define |:command-completion-custom| functions.
Returns what vim would have expanded for the command contained in the {lead}
string.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#matching_askvim()*           {{{3
lh#command#matching_askvim(attribute, lead)~
Helper function to define |:command-completion-custom| functions.
Returns what vim would have expanded for |:command-complete| {attribute}.

For instance:
- To obtain the list of known options >
    let opts = lh#command#matching_askvim('option', '')
- To obtain the list of active mappings: >
    let opts = lh#command#matching_askvim('mapping', '')
<  WARNING: This will not work correctly with vim versions that don't have
    |getcmdline()|.
    Mapping list will end at the first mapping keybinding with a double quote
    in it.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#matching_bash_completion()*  {{{3
lh#command#matching_bash_completion(command, lead [, directory])~
Helper function to define |:command-completion-custom| functions.
Returns what `bash`  would have expanded for {command} + {lead}, when executed
in the optional {directory}.

It's specially meant for `bash` commands with a completion scheme defined with
`complete -F`.
@see also |lh#command#matching_make_completion()| which has been dedicated to
`make`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#matching_make_completion()*  {{{3
lh#command#matching_make_completion(lead [, directory])~
Helper function to define |:command-completion-custom| functions.
Returns what `bash`  would have expanded for `make` + {lead}, when executed
in the optional {directory}.
@see the underlying |lh#command#matching_bash_completion()| function.

@note This function caches results until the `Makefile` present in {directory}
is updated.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#command#new()*                       {{{3
Highly Experimental.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                       *lh#command#Fargs2String()*              {{{3
lh#command#Fargs2String({aList})~
@param[in,out] aList list of params from <f-args>
@see tests/lh/test-Fargs2String.vim

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                            *lh#command#complete()*                  {{{3
lh#command#complete({argLead}, {cmdLine}, {cursorPos})~
Under developpement

------------------------------------------------------------------------------
BUFFER RELATED FUNCTIONS                              *lhvl#buffer*     {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#buffer#get_nr()*              {{{3
lh#buffer#get_nr()~
@returns the buffer number associated to a buffername/filename.
If no such file is known to vim, a buffer will be locally created.

This function is required to assign a new buffer number to be used in qflist,
after the filenames have been fixed -- see BTW's `s:FixCTestOutput()`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#buffer#list()*                {{{3
lh#buffer#list()~
@return The |List| of |buflisted| buffers.

e.g.: >
 echo lh#list#transform(lh#buffer#list(), [], "bufname")

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#buffer#Find()*                {{{3
lh#buffer#Find({filename})  (*deprecated*)~
                                                *lh#buffer#find()*
lh#buffer#find({filename})~
Searchs for a window where the buffer is opened.

@param {filename}
@return The number of the first window found, in which {filename} is opened.

If {filename} is opened in a window, jump to this window. Otherwise, return
-1.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#buffer#Jump()*                {{{3
lh#buffer#Jump({filename}, {cmd})  (*deprecated*)~
                                                *lh#buffer#jump()*
lh#buffer#jump({filename}, {cmd})~
Jumps to the window where the buffer is opened, or open the buffer in a new
windows if none match.

@param {filename}
@param {cmd}
@return Nothing.

If {filename} is opened in a window, jump to this window.
Otherwise, execute {cmd} with {filename} as a parameter. Typical values for
the command will be "`sp`" or "`vsp`". (see |:split|, |:vsplit|).

N.B.: While it is not the rationale behind this function, other commands that
does not open the buffer may be used in the {cmd} parameter.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#buffer#Scratch()*             {{{3
lh#buffer#Scratch({bname},{where})  (*deprecated*)~
                                      *scratch* *lh#buffer#scratch()*
lh#buffer#scratch({bname},{where})~
Split-opens a new scratch buffer.

@param {bname} Name for the new scratch buffer
@param {where} Where the new scratch buffer will be opened ('', or 'v')
@return The buffer number of the new scratch buffer.
@post          The buffer has the following properties set:
                   'bt'=nofile, 'bh'=wipe, 'nobl', 'noswf', 'ro'

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                             *lhvl-dialog*      *lh#buffer#dialog#*               {{{3
Functions for building interactive dialogs~
Unlike other |lh-vim-lib| functions which can be used independently from each
others, all the `lh#buffer#dialog#*()` functions constitute a coherent framework
to define interactive dialogs.

For the moment it only supports the selection of one or several items in a
list.

From a end-user point of view, a list of items is displayed in a (|scratch|)
buffer. If enabled, the user can select (/tag) one or several items, and then
validate its choice. He can always abort and quit the dialog. A few other
features are also supported: a help message can be shown, the list may be
colored, etc.


The items displayed can be of any kind (function signatures, email addresses,
suggested spellings, ...), as well as the validating action.  The
help-header can be customized, as well as colours, other mappings, ...

However the list displaying + selection aspect is almost hardcoded.


How it works~
------------
Scripts have to call the function                    *lh#buffer#dialog#new()*
  lh#buffer#dialog#new(bname, title, where, support-tagging, action, choices)~
with:
- {bname} being the name the |scratch| buffer will receive.
- {title} the title that appears at the first line of the scratch buffer.
  I usually use it to display the name of the "client" script, its version,
  and its purpose/what to do.
- {where} are |:split| options (like "bot below") used to open the scratch
  buffer.
- {support-tagging} is a boolean (0/1) option to enable the multi-selection.
- {action} is the name of the callback function or a |dictionary| of
  map-trigger <-> actions.
- {choices} is the |List| of exact strings to display.

The `#new` function builds and returns a |Dictionary|, it also opens and fills
the scratch buffer, and put us within its context -- i.e. any |:map-<buffer>|
or other buffer-related definitions will done in the new scratch buffer.

Thus, if we want to add other mappings, and set a syntax highlighting for the
new buffer, it is done at this point (see the *s:PostInit()* function in my
"client" scripts like |lh-tags|).
At this point, I also add all the high level information to the
dictionary (for instance, the list of function signatures is nice, but
it does not provides enough information (the corresponding file, the
command to jump to the definition/declaration, the scope, ...)

The dictionary returned is filled with the following information:
- buffer ids,
- where was the cursor at the time of the creation of the new scratch buffer,
- name of the callback function.


Regarding the callback function: *lhvl-dialog-select-callback*
- It can not be a |script-local| function, only global and autoload functions
  are supported.
- When called, we are still within the scratch buffer context.
- It must accept a |List| of numbers as its first parameter: the index (+1) of
  the items selected.
- The number 0, when in the list, means "aborted". In that case, the
  callback function is expected to call |lh#buffer#dialog#quit()| that will
  terminate the scratch buffer (with |:quit|), and jump back to where we were
  when `#new` was called, and display a little "Abort" message.
- We can terminate the dialog with just :quit if we don't need to jump
  back anywhere. For instance, lh-tags callback function first
  terminates the dialog, then jumps to the file where the selected tag
  comes from.

- It's completely asynchronous: the callback function does not return anything
  to anyone, but instead applies transformations in other places.
  This aspect is very important. I don't see how this kind of feature can work
  if not asynchronously in vim.

- Since v4.7.1, there are two ways to fill the {action} parameters. It can be
  either a function name that'll be bound to `<CR>` or a series of mapping
  triggers <-> function names/references ;
  e.g. from lh-cpp |:Override| command: >
      let b_id = lh#buffer#dialog#new(
            \ 'override://'.substitute(a:className, '[^A-Za-z0-9_.]', '_', 'g' ),
            \ 'Overrideable functions for '.a:className,
            \ 'bot below',
            \ 1,
            \ { '\<CR\>': 'lh#cpp#override#select',
            \   'd': {l -> lh#cpp#override#select(l, 1)}
            \ },
            \ choices
            \)
<  Note: Special keys need to be escaped, see |lh#mapping#reinterpret_escaped_char()|.

How to customize it:
- *lh#buffer#dialog#quit()* can be explicitly called, from a registered select
  callback (|lhvl-dialog-select-callback|), in order to terminate the dialog.
- *lh#buffer#dialog#add_help()* can be used to complete the help/usage message
  in both its short and long form.
- *lh#buffer#dialog#update()* can be called after the list of items has been
  altered in order to refresh what is displayed. The rationale behind this
  feature is to support sorting, filtering, items expansion, etc. See
 |lh-tags| implementation for an example.
- *lh#buffer#dialog#select()* can be used in new mappings in order to handle
  differently the selected items.
 |lh-tags| uses this function to map 'o' to the split-opening of the selected
  items.
  NB: the way this feature is supported may change in future releases.

Limitations:
This script is a little bit experimental (even if it the result of almost 10
years of evolution), and it is a little bit cumbersome.
- it is defined to support only one callback -- see the hacks in |lh-tags| to
  workaround this limitation.
- it is defined to display list of items, and to select one or several items
  in the end.
- and of course, it requires many other functions from |lh-vim-lib|, but
  nothing else.

------------------------------------------------------------------------------
WINDOW RELATED FUNCTIONS                              *lhvl#window*     {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#window#create_window_with()*  {{{3
lh#window#create_window_with(cmd)~
@param {cmd} |window| creation |command|
This function tries to create a new window with the window creation command
passed, typically |:new|, |:split|, |:vsplit|, etc.
If the creation fails because of |E36|, it will be attempted again, and once
only, after increasing by one the current windows size.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#window#new()*                 {{{3
                                                *lh#window#split()*
lh#window#new({bufname})~
lh#window#split([{options}])~
Encapsulations over |lh#window#create_window_with()|.
The first tries to execute `:new {bufname}`;
The second tries to execute `:split {options}`

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#window#getid()*               {{{3
lh#window#getid([{win}])~
@since version 3.9.0
Encapsulation over vim recent function |win_getid()|.
An emulation is provided for older versions of vim.
This function associates (on-the-fly) a unique window-id to a |window| know from
its window number, and return the associated window-id.

Notes:
- While window numbers may change as windows get reorganized, window ids are
  stable and never change.
- The emulation injects a *w:id* variable into each window for which an id is
  requested.
- The emulation doesn't emulate yet the second optional {tab} argument of
  |win_getid()|.

Function meant to be used along with |lh#window#gotoid()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#window#gotoid()*              {{{3
lh#window#gotoid({id})~
@since version 3.9.0
Encapsulation over vim recent function |win_gotoid()|.
An emulation is provided for older versions of vim.
This function jumps to the window that has the window id {id}.

Note: While window numbers may change as windows get reorganized, window ids
are stable and never change.
Function meant to be used along with |lh#window#getid()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#window#text_width()*          {{{3
lh#window#text_width({winnr})~
@since version 4.7.0
Return the actual width available to display text in the current window.
Indeed |winwidth()| doesn't take the columns used for signs and folding into
account.

IOW, this function returns: >
    winwidth() - &foldcolumn - (&signcolumn * 2)

------------------------------------------------------------------------------
QUICKFIX RELATED FUNCTIONS                            *lhvl#quickfix*   {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#qf#get_metrics()*             {{{3
lh#qf#get_metrics()~
@since version 4.7.0
@returns a |Dictionary| that counts the numbers of errors and warnings found
in the |quickfix| list.
 - "`all`"      = number of recognized error messages (see |getqflist()| `valid` entry)
 - "`errors`"   = number of actual error found (`type=='E' || text=~'error||erreur'`)
 - "`warnings`" = number of actual warning found (`type=='W' || text=~'warning||attention'`)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#qf#get_title()*               {{{3
lh#qf#get_title()~
@since version 4.5.0
@returns the title of the |quickfix-window|, even on versions of Vim where >
    getqflist({'title':1})
isn't supported.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#qf#get_winnr()*               {{{3
lh#qf#get_winnr()~
@since version 4.5.0
@returns Window number of the |quickfix-window|, or 0 if it isn't opened.
@note    |location-list-window|s are ignored.

It works even on versions of Vim where >
    filter(getwininfo(), 'v:val.quickfix && !v:val.loclist')[0].winnr
isn't supported.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#qf#is_displayed()*            {{{3
lh#qf#is_displayed()~
@since version 4.5.0
@returns whether the |quickfix-window| is opened.
@note    |location-list-window|s are ignored.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#qf#make_context_map()*        {{{3
lh#qf#make_context_map(required)~
@since version 4.5.0
@param[in] {required} Helps detecting cases when the availability of the
                      option is critical
@returns a |lhvl#object| that helps associate context to a |quickfix-list|.
@pre *lh#has#properties_in_qf()* || not {required} // `has('patch-7.4.2200')`

Creates a |dictionary|-map that'll (externally) associate a context to a
|quickfix-list|.

Rationale:~
This feature is somehow redundant to |quickfix-context|. The difference is
that different plugins may want to use the context for their own purpose.
Typically plugins that encapsulate compilation or searching may want to store
the exact command-line, or some other high level information like a
compilation mode (/Release/, /Debug/...)...
If another plugin that works on quickfix lists needs to associate un unrelated
information to each list, then there is a high risk of conflict on their usage
of the |quickfix-context|.
That's the rationale behind `lh#qf#make_context_map()`: to be able to
associate a context without any possible interference from other plugins.

Unfortunatelly, this feature won't be available before the quite recent (at
this time) Vim 7.4.2200. Hence, the {required} flag. If the version
requirement cannot be satisfied, and in the feature isn't really important in
your plugins, thay you can say "this is not required". Thanks to that, all
methods will return the value 0 -- which by the way is |empty()|.

Methods:~
*lh#qf#make_context_map().get_id()*
Returns the |quickfix-ID| of the current quickfix list

*lh#qf#make_context_map().get()* --> `.get(key [, id])`
Returns the values previously associated to the {key} for the specified (or
current) |quickfix-ID|.

*lh#qf#make_context_map().set()* --> `.set(key, value [, id])`
Associates a {value} to the {key} for the specified (or current) |quickfix-ID|.
The plugin has been developped with the idea the {value} would be a
|dictionary| or a |list|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#qf#set_title()*               {{{3
lh#qf#set_title({title})~
@since version 5.1.0
Sets the title of the |quickfix-window|, even on versions of Vim where >
    setqflist([], 'a', {'title': title})
isn't supported.

------------------------------------------------------------------------------
SYNTAX RELATED FUNCTIONS                              *lhvl#syntax*     {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#syntax#getline_matching()*          {{{3
lh#syntax#getline_matching({lnum}, {syn-pattern})~
@param {lnum}        line of the character
@param {syn-pattern} |regex| matched against |synIDattr()|.
@pre {lnum} shall be a |Number|.
@return a string made of the characters from line {lnum}, without the
characters with a syntax ID matching {syn-pattern}.
@since Version 4.0.0
@see also |lh#syntax#getline_not_matching()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#syntax#getline_not_matching()*      {{{3
lh#syntax#getline_not_matching({lnum}, {syn-pattern})~
@param {lnum}        line of the character
@param {syn-pattern} |regex| matched against |synIDattr()|.
@pre {lnum} shall be a |Number|.
@return a string made of the characters from line {lnum}, without the
characters with a syntax ID matching {syn-pattern}.
@since Version 4.0.0
@see also |lh#syntax#getline_matching()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                        *lh#syntax#is_a_comment_at()*  *lh#syntax#is_a_comment()*         {{{3
lh#syntax#is_a_comment({mark})~
lh#syntax#is_a_comment_at({lnum}, {col})~
@param {mark}  position of the character
@param {lnum}  line of the character
@param {col}   column of the character
@return whether the character is within a Comment syntax element.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#syntax#line_filter()*      {{{3
lh#syntax#line_filter({syn-pattern})~
@param {syn-pattern} |regex| matched against |synIDattr()|.
@return an |lhvl#object| that permits to filter lines to keep only characters
matching (or not matching a given) {syn-pattern}.

The object provides the two services:
- `getline_matching({lnum})`
- `getline_not_matching({lnum})`

This filter is an optimized version of |lh#syntax#getline_matching()|, and
|lh#syntax#getline_not_matching()| aimed at processing several lines.

@since Version 4.0.0
@see also |lh#syntax#getline_matching()|, and |lh#syntax#getline_not_matching()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#syntax#match_at()*             {{{3
lh#syntax#match_at({syn-pattern}, {lnum}, {col})~
@param {lnum}        line of the character
@param {col}   column of the character
@param {syn-pattern} |regex| matched against |synIDattr()|.
@return whether the character ar {lnum}, {col} matches {syn-pattern}.
@since Version 4.0.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#syntax#name_at()*              {{{3
                                                *lh#syntax#NameAt()*
lh#syntax#name_at({lnum},{col}[,{trans}])~
lh#syntax#NameAt({lnum},{col}[,{trans}])  (*deprecated*)~
@param {lnum}  line of the character
@param {col}   column of the character
@param {trans} see |synID()|, default=0
@return the syntax kind of the given character at {lnum}, {col}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#syntax#name_at_mark()*         {{{3
                                               *lh#syntax#NameAtMark()*
lh#syntax#NameAtMark({mark}[,{trans}])  (*deprecated*)~
lh#syntax#name_at_mark({mark}[,{trans}])~
@param {mark}  position of the character
@param {trans} see |synID()|, default=0
@return the syntax kind of the character at the given |mark|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       *lh#syntax#Skip()* *lh#syntax#SkipAt()* *lh#syntax#SkipAtMark()*           {{{3
lh#syntax#Skip()                (*deprecated*)~
lh#syntax#SkipAt({lnum},{col})  (*deprecated*)~
lh#syntax#SkipAtMark({mark})    (*deprecated*)~
       *lh#syntax#skip()* *lh#syntax#skip_at()* *lh#syntax#skip_at_mark()*
lh#syntax#skip()~
lh#syntax#skip_at({lnum},{col})~
lh#syntax#skip_at_mark({mark})~

Functions to be used with |searchpair()| functions in order to search for a
pair of elements, without taking comments, strings, characters and doxygen
(syntax) contexts into account while searching.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               *lh#syntax#list_raw()*             {{{3
lh#syntax#list_raw({name})~
@param {group-name}
@return the result of "syn list {group-name}" as a string

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#syntax#list()*                {{{3
lh#syntax#list()~
@param {group-name}
@return the result of "syn list {group-name}" as a list.

This function tries to interpret the result of the raw list of syntax
elements.

------------------------------------------------------------------------------
OS/SYSTEM RELATED FUNCTIONS                           *lhvl#os*         {{{2

                                              *lh#os#has_unix_layer_installed()*  {{{3
                                              *g:unix_layer_installed*
Presence of an Unix-like layer ~
It is possible to specify that Unix tools are available on a non Unix system.
For instance, you may have installed Cygwin or Unixutils on a MsWindows box, and
you may want to use unix-tools from Vim even if Vim has not been launched from
an Unix shell but from Microsoft's files explorer.

So, as a Vim user having lh-vim-lib installed, you may be interested in
setting the boolean global variable |g:unix_layer_installed| into your .vimrc.

Vim-script language programmers can know if such an Unix layer has been
installed thanks to the boolean function: |lh#os#has_unix_layer_installed()|.

Note: This old feature has been moved to lh-vim-lib from |system-utils|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#system_detected()*           {{{3
Environment Detection~
When loaded, this plugin tries to detect the kind of system Vim runs on.
Is it (or does it looks like) an Unix system ? Or is it a Microsoft system ?

Note: At this time, I don't manage old Macintosh OSes or any other OS.

Detection algorithm ~
The criteria used to detect the system are:
- first: 'shell' =~ "`sh`" -> the shell Vim is started with (cf. |SHELL|) looks
  like an Unix shell, then the system is recognized as an "unix" system -- even
  if Vim was started from Cygwin on a Microsoft platform.
- then: `has('win16')` or `win32` or `win64` or `dos16` or `dos32` -> the system is
  recognized as an "`msdos`" (ersatz) system.
- otherwise: an error message is raised -> contact me in order to enhance the
  plugin and support other configurations.

Vim-script language programmers can know the system detected thanks to the
function |lh#os#system_detecte()|.

Note: This old feature has been moved to lh-vim-lib from |system-utils|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#OnDOSWindows*                {{{3
lh#os#OnDOSWindows()~
This function returns whether any of `has('win16')`, `win32,` `win64,` `dos16,` `dos32,`
or `os2` is true.

Note: This old feature has been moved to lh-vim-lib from |system-utils|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#chomp()*                     {{{3
lh#os#chomp({text})~
Returns the {text} without the trailling newline character.
It helps to clean |system()| results from extra newlines at the end of the
result.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#make()*                      {{{3
lh#os#make({options}, {bang} [, makeprg])~
This is a shortcut to: >
    exe ':make '.bang.' '.option

Any |p:$env| variable will be injected on the fly.
|'makeprg'|setting can be overriden locally for the duration of the call.
@internal a temporary script will be created for the occasion.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#new_runner_script()*         {{{3
lh#os#new_runner_script({cmd}, {env})~
This'll create a finalizable script to execute in 'shell' that initialises
environment variables, and execute a command.

You'll find in the |dictionary|:
- `"_script_name"` that contain the name of the temporary script created
- `"run()"` that'll execute the script
- `"lines"` that caches the lines stored in the temporary script.

By _finalizable_, understand that the result inherits |lh#on#exit()|, and that
finalization will |delete()| the temporary file created by the function.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#system()*                    {{{3
lh#os#system({command)})~
This is a shortcut to: >
    lh#os#chomp(system(cmd))

Any |p:$env| variable will be injected on the fly.
@internal a temporary script will be created for the occasion.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#sys_cd()*                    {{{3
lh#os#sys_cd({command)})~
This function is a wrapper that returns (as a string) the name of the program
to use according to its associated task (change directory).

It will change current directory for the next command executed.
Unlike |:cd|, the new directory doesn't affect Vim, only what it executed
through |:make|, |system()|, |:!|, ...

The function expects an optional list of files and parameters (expressed in the UNIX
form: '-param'). Every filename passed to this function is converted to an
usable form (by the shell and the tool wrapped) thanks to |lh#path#fix()|.

Exemple: >
    let res = lh#os#system(lh#os#sys_cd(b:tags_dirname) . ' && ctags '.options)

Note: This old feature has been moved to lh-vim-lib from |system-utils|. Other
similar UNIX commands remains to be moved. See |SU-wrapper-functions|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#cpu_number()*                {{{3
lh#os#cpu_number()~
Returns the number of CPU of the current machine.

It will use /proc/cpuinfo when it exists, or $NUMBER_OF_PROCESSORS on Windows.
-1 is returned otherwise.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#cpu_cores_number()*          {{{3
lh#os#cpu_cores_number()~
Returns the number of cores of the current machine.

It will use /proc/cpuinfo when it exists.
-1 is returned otherwise. (This is not supported, yet, on Windows)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#os#lcd()*                       {{{3
lh#os#lcd(path)~
Executes `:lcd fnameescape({path})` and log the command along the way.
See |:lcd|, |fnameescape()|.

------------------------------------------------------------------------------
PYTHON RELATED FUNCTIONS                              *lhvl#python*     {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#python#best_still_avail()*      {{{3
lh#python#best_still_avail([preferred order])~
Without imposing a version of python (which `has('python')` or
`has('python3')` do), this function returns the best python flavour we can
still use.
Note: When vim has (internally) started to use a version on Python, we cannot
use another one. See |E837|.
If your version of Vim has been compiled with support of Python2 and Python3,
compare the results of: >

    $>vim -U NONE -u NONE -c 'echo has("python").has("python3")'
    $>vim -U NONE -u NONE -c 'echo has("python3").has("python")'

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#python#has()*                   {{{3
lh#python#has()~
@returns has('python_compiled') || has('python3_compiled')
This function tells whether python is available without imposing a version of
Python. See |lh#python#best_still_avail()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#python#can_import()*            {{{3
lh#python#can_import({modname})~
@returns whether `:{bestpy} import {modname}` succeeds.
The {bestpy} python flavour is determined by |lh#python#best_still_avail()|.
@post a Python version is imposed at the end of this function.
@see also |lh#python#externa_#can_import()|.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#python#external_can_import()*   {{{3
lh#python#external_can_import({modname})~
@returns whether `system('python -c "import {modname}")` succeeds.
Unlike the |lh#python#can_import()|, the function does not impose a version of
Python.
@see also |lh#python#can_import()|.

------------------------------------------------------------------------------
COMPLETION RELATED FUNCTIONS                          *lhvl#completion* {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#icomplete#new()*                {{{3
                                              *lh#icomplete#new_on()*
lh#icomplete#new(startcol, matches, Hook)~
lh#icomplete#new_on(pattern, matches, Hook)~
Prepares an |omni-completion| menu on the text starting at {startcol} or that
matches {pattern} just before the cursor.
The items displayed in the menu comes from the {matches}.
When completion succeeds, the {Hook} |lhvl-functor| is called with the
selected item as parameter.

In order to start the menu, execute *start_completion()* on the |Dict| object
returned by these functions.
NB: I may automate the start in the future.

For more information on:
- {startcol}, see |complete-functions|
- {matches}, see |complete-items|

So far, no special handling of the |preview-window| is done.

When in completion, the following keybindings are made in complement of
|popupmenu-keys|:
<CR>  behaves as CTRL-Y: Accept the currently selected match and stop completion
<ESC> behaves as CTRL-E: End completion, go back to what was there before
                         selecting a match (what was typed or longest common string)
<Tab>/<S-Tab>            Cycles to the next/previous match

Example: >
  let entries = [
        \ {'word': 'un', 'menu': 1, 'kind': 's', 'info': ' '},
        \ {'word': 'deux', 'menu': 2, 'kind': 's', 'info': 'takes a parameter'},
        \ {'word': 'trois', 'menu': 3, 'info': ''},
        \ {'word': 'trentre-deux', 'menu': 32, 'info': ''},
        \ 'unit'
        \ ]
  inoremap <silent> <buffer>  <c-o>:call lh#icomplete#new_on('\w', entries, 'lh#common#warning_msg("nominal: ".v:val)').start_completion()<cr>


See also |mu-template| autoload/lh/mut.vim.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *lh#icomplete#run()*                {{{3
lh#icomplete#run(startcol, matches, Hook)~
@deprecated Prefer |lh#icomplete#new()| and |lh#icomplete#new_on()|.
Runs |complete()| and registers the {Hook} to be executed when the user
selects one entry in the menu.

------------------------------------------------------------------------------
LOG RELATED FUNCTIONS                                 *lhvl#log*        {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lhvl-global-logger*              {{{3
lh-vim-lib provides a global logger since version 3.6.0.

By default, it'll echo everything with |:echomsg| (through |lh#log#echomsg|).

The logging policy can be set thanks to |lh#log#set_logger()|.
In plugins, logging can be done directly thanks to |lh#log#this()|, or though
an encapsulation, see below.

This logger doesn't support log level directly. Instead, the recommended way
to use it is to have logging helper functions in each plugins (autoload
plugins, or plain plugins, ftplugins, ...)  and to have these functions test a
plugin related verbose option to decide whether they log anything or not.
I use |mu-template| skeletons for vim plugins to automatically define these
functions in my plugins.

It looks like this: >
    " # Debug
    let s:verbose = get(s:, 'verbose', 0)
    function! lh#icomplete#verbose(...)
      if a:0 > 0
        let s:verbose = a:1
      endif
      return s:verbose
    endfunction

    function! s:Log(...)
      call call('lh#log#this', a:000)
    endfunction

    function! s:Verbose(...)
      if s:verbose
        call call('s:Log', a:000)
      endif
    endfunction


Thus, if I want to trace what is done in my icomplete autoload plugin, I call >
    call lh#icomplete#verbose(1)

If I want to disable completely all logs, I can execute: >
    :call lh#log#set_logger('none')

If I prefer to see my traces on the right side, and in a |quickfix-window| in
order to trace the files + line numbers along with the message to log, I'll
execute >
    :call lh#log#set_logger('qf', 'vert')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#set_logger()*             {{{3
lh#log#set_logger(kind [, options])~
Sets the global logger.
@param[in] {kind} Depending on {kind}, the global logger becomes:
  - `"none"`    -> |lh#log#none()| and won't ever log anything
  - `"echomsg"` -> |lh#log#echomsg()| and log with |:echomsg|
  - `"qf"`      -> |lh#log#new()| and log in |quickfix-window|
                Takes another parameter that tells {where} the window is opened.
  - `"loc`      -> |lh#log#new()| and log in |location-list-window|
                Takes another parameter that tells {where} the window is opened.
  - `"file"`    -> |lh#log#new()| and log in a file named {where}
                @since v4.0.0


                                                *:LHLog*                          {{{3
:LHLog {kind} [{where}]~
Sets the global logger.
@param {kind} any of `"none"`, `"echomsg"`, `"qf"`, `"log"`, `"file"` and `"clear"`

This command is simply a helper command that'll execute
|lh#log#set_logger()||. It presents the advantage to support completion: i.e.
no need to remember all possible parameter values.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#this()*                   {{{3
lh#log#this({format}, {args}...)~
Logs the formatted message with the global logger.
The message to log is prepared with |lh#fmt#printf()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#callstack()*              {{{3
lh#log#callstack(msg)~
Logs the current callstack with the global logger.
Relies on |lh#log#exception()|
@since Version 3.13.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#exception()*              {{{3
lh#log#exception([{exception} [, {throwpoint}]])~
Logs the {exception} with the global logger.
If the global logger logs to the quickfix-window or to a location-list window,
the callstack will also be logged.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#new()*                    {{{3
lh#log#new({where}, {kind})~
@param {where} Specifies where the list buffer shall appear ("vert", "lefta",
               "abo" -- see |:vert|, |:lefta|, |:abo|)
@param  {kind} Kind of list to fill:
               - "qf":  |quickfix|-list
               - "loc": |location-list|
@returns a logger object that provides
 - `log({msg})` -- adds a message to the qf/loclist (see |quickfix|)
 - `reset()`    -- reset the qf/loclist; and returns `self`
 - `clear()`    -- clears the qf/loclist
 - `open()`     -- opens the qf/loclist
It's isn't meant to be used directly. See |lhvl-global-logger|.

@note In order to obtain the name of the calling function, an exception is
thrown and the backtrace is analysed.
In order to work, this trick requires:
- A reasonable callstack size (past a point, vim shortens the names returned
  by |v:throwpoint|.
- Named functions ; i.e. |anonymous-function|s (i.e. functions defined on
  dictionaries and not attached to them) will have their names mangled
  (actually it'll be a number) and |lh#exception#callstack()| won't be able to
  decode them.  i.e.: >
     function s:foo() dict abort
        logger.log("here I am");
     endfunction
     let dict.foo = function('s:foo')
<  will correctly fill the quicklist/loclist, but >
     function dict.foo() abort
        logger.log("here I am");
     endfunction
<  won't.
- Calls to the logging internal function can be wrapped into other functions.
  However finding the depth between the function that do actually log and the
  user function that wants to log, I had to adopt a convention: any function
  with a name that contains `log` or `verbose` (which ever the case) will be
  ignored.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#echomsg*                  {{{3
lh#log#echomsg()~
@return a logger that prints messages with |:echomsg|
It provides the following no-op functions
 - `log({msg})` -- display message with |:echomsg|
 - `reset()`    -- no-op that still returns `self`
It's isn't meant to be used directly. See |lhvl-global-logger|.

Typical use, see |lh#log#set_logger()|: >
    call lh#log#set_logger('none')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#log#none()*                   {{{3
lh#log#none()~
@return a logger that does nothing.
It provides the following no-op functions
 - `log({msg})` -- no-op
 - `reset()`    -- no-op that still returns `self`
It's isn't meant to be used directly. See |lhvl-global-logger|.

Typical use, see |lh#log#set_logger()|: >
    call lh#log#set_logger('none')

------------------------------------------------------------------------------
VERSION CONTROL SYSTEM RELATED FUNCTIONS              *lhvl#vcs*        {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#as_http()*               {{{3
lh#vcs#as_http([dirname])~
@param[in] {dirname} repository dirname, defaults to `expand(%:p:h)`.
@return the url associated to the {dirname} expressed in http form.
@warning Only github is supported right now.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#decode_github_url()*     {{{3
lh#vcs#decode_github_url(url)~
@param[in] {url} of a github repository
@return a |List| made of:
- `"ssh"`  if detected in the url
- github username name
- project name

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#get_git_root()*          {{{3
lh#vcs#get_git_root([path])~
Searches for a up-directory from {path} that contains a `.svn/` subdirectory.
@param[in] {path} repository dirname, defaults to `expand(%:p:h)`.
@return the matching directory name, or an empty string.
@version 3.12.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#get_svn_root()*          {{{3
lh#vcs#get_svn_root([path])~
Searches for a up-directory from {path} that contains a `.svn/` subdirectory.
@param[in] {path} repository dirname, defaults to `expand(%:p:h)`.
@return the matching directory name, or an empty string.
@warning This won't work well with older subversion clients that put a `.svn/`
directory into each directory checked out.
@version 3.12.0

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#get_type()*              {{{3
lh#vcs#get_type([path])~
@param[in] {path} repository dirname, defaults to `expand(%:p:h)`.
@return the type of VCS detected. Uses |VCSCommand| routines if installed.
Otherwise, only `git` and `svn` are recognized.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#get_url()*               {{{3
lh#vcs#get_url([path])~
@param[in] {path} repository dirname, defaults to `expand(%:p:h)`.
@return the `remore.origin` url associated to the repository.
@warning Only git repositories are supported at the moment.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#is_git()*                {{{3
lh#vcs#is_git([path])~
@param[in] {path} repository dirname, defaults to `expand(%:p:h)`.
@return whether the {path} belongs to a git repository.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#vcs#is_svn()*                {{{3
lh#vcs#is_svn([path])~
@param[in] {path} repository dirname, defaults to `expand(%:p:h)`.
@return whether the {path} belongs to a svn repository.

------------------------------------------------------------------------------
OO HELPERS                                            *lhvl#oo*         {{{2
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Quite a few times I've defined |Dictionaries| that behave as objects, but when
I wanted to display their value, I've been annoyed to see a gigantic (and
useless) list of methods. Hence the following helpers.
For the moment only stringification is addressed, may be other services will
be provided in the future. I can't tell.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#object#make_top_type()*   {{{3
lh#object#make_top_type(dict-params)~
Creates a |Dictionary| that implements:
- *__lhvl_oo_type()*
  that returns 1 -- meant to be checked w/ `get(obj, '__lhvl_oo_type', 0)`
- *_to_string()*
  that stringifies the current object without its methods.
  Call `lh#object#verbose(1)` to also display the list of methods.

In order to have a dedicated stringification method, just override `_to_string()`
to an implementation that fits your needs. You may need to use
|lh#object#_to_string()| in order to display internal fields without recursion
issues.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#object#to_string()*       {{{3
lh#object#to_string(data)~
This function will work as `:echo data`, i.e. multiple occurrences of a same
object will be shorten to `[...]` or `{...}`, but it will also hide methods
from objects created with |lh#object#make_top_type()|, or it'll call a
`_to_string()` or a `to_string()` when found.

Internally, it relies on |lh#object#_to_string()| to build the string to
display. Actually, it's just a call to: >
    lh#object#_to_string(a:data, [])
<
                                                 *lh#object#_to_string()*      {{{3
lh#object#to_string(data, list_of_already_handled_data)~
This is the internal function used to print objects once. Unless you're
defining your own `_to_string()` overload, don't use it. See
autoload/lh/object.vim `s:to_string()` implementation to see how to use it.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#object#is_an_object()*    {{{3
lh#object#is_an_object(var)~
@return whether the {var} is an object. It tests whether it contains a
`'__lhvl_oo_type'` field which is automatically added to objects built through
|lh#object#make_top_type()|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#object#inject()*          {{{3
lh#object#inject({object}, {method-name}, {function-name}, {snr})~
@since Version 4.0.0
Adds a method named {method-name} to {object}. The method will point to the
|local-function| (in the script of id {snr}, or named {snr}) named
{function-name}.
@see also |lh#object#inject_methods()|

This function is meant to be used by plugin writers while in maintenance.

My typical scenario is: I get an object through something like >
  " autoload/lh/foo.vim
  if !exists('s:obj')
    let s:obj = lh#foo#make_bar()
  endif

This function binds several methods to `s:obj`.
I keep the object around even when I |:source| `autoload/lh/foo.vim` again.
I modify `lh#foo#make_bar()` in order to bind a new method `x()` to `s:obj`.
Problem: I can't run the function again as the object isn't modified, but I
want to test/use the new function. Here comes to rescue: >
  :call lh#object#inject(s:obj, 'x', 'get_x', 'autoload/lh/foo.vim')

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#object#inject_methods()*  {{{3
lh#object#inject_methods({object}, {snr}, {method-names...})~
@since Version 4.0.0
Adds a method named {method-name} to {object}. The method will point to the
|local-function| (in the script of id {snr}, or named {snr}) named
{function-name}.
@see also |lh#object#inject()|

This function is meant to help define new objets. Given the script
|local-function|s `s:get()`, `s:set()`, `s:name()`, etc., instead of defining
a `s:getSNR()` function and a new object with: >

    " autoload/lh/foo/bar.vim
    function! lh#foo#bar#new() abort
      let res = lh#object#make_top_type({})
      let res.get  = function(s:getSNR('get'))
      let res.set  = function(s:getSNR('set'))
      let res.name = function(s:getSNR('name'))
      ...
      return res
    endfunction

we could in one call: >
    " autoload/lh/foo/bar.vim
    let s:k_script_name = expand('<sfile>:p')
    function! lh#foo#bar#new() abort
      let res = lh#object#make_top_type({})
      call lh#object#inject_methods(res, s:k_script_name, ['get', 'set', 'name'...])
      return res
    endfunction

------------------------------------------------------------------------------
VARIABLE HELPERS                                      *lhvl#variables*  {{{2

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#let#if_undef()*  *:LetIfUndef* {{{3
lh#let#if_undef({varname}, {value})~
:LetIfUndef {varname} {value}~
:LetIfUndef {varname} = {value}~
@param[in] {varname} scoped named of a variable (|w:|, |b:|, |p:|, |P:|, |t:|,
                     |g:|), or environment variable.
@param[in] {value}
@return variable built

@note |command-completion| is supported on {varname}.
@warning
    The interface has changed with v4.0.0, {value} must no longer be quoted.
@warning
    Environment variable only support string and numeric values.
@warning
    The command flavor (and the next one that takes a {assignment-string})
    only support expressions that aren't modified by function context. I.e.
    variables must be explictly global, buffer-, windows-, or tab-local.  |s:|
    variables won't give the correct result, nor expressions like
    `expand('<sfile>')`.

lh#let#if_undef({assignment-string})~
Flavour meant to be used internally by |:LetIfUndef|

These function and command make sure the variable named {varname} exists. If
it didn't exist before, it's assigned to {value}.
The {varname} can be a |Dictionary| with all its fields.

Examples: >
    call lh#let#if_undef('g:dummy_test1', 42)
    LetIfUndef g:dummy_test1 42
    LetIfUndef g:dummy_test1 = 42

    LetIfUndef g:dummy_test1 = some#func(g:var+t:var) " OK
    LetIfUndef g:dummy_test1 = s:(g:var+t:var)        " Error
    LetIfUndef g:dummy_test1 = some#func(var)         " Error

    call lh#let#if_undef('g:dummy_test2', {'a':1, 'b':{'c':5}})
    LetIfUndef g:dummy_test2.un.deux {'a':1, 'b':{'c':5}})
    LetIfUndef g:dummy_test2.un.deux = {'a':1, 'b':{'c':5}})

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#let#to()*        *:LetTo*      {{{3
lh#let#to({varname}, {value}[, {hide-or-overwrite}])~
:LetTo [--hide|--overwrite] {varname} {value}~
:LetTo [--hide|--overwrite] {varname} = {value}~
@param[in] {varname} scoped named of a variable (|w:|, |b:|, |p:|, |P:|, |t:|,
                     |g:|), or environment variable.
@param[in] {value} assigned, must no be quoted
@param[in] {hide-or-overwrite} see below
@return variable built

@note |command-completion| is supported on {varname}.
@warning
    The interface has changed with v4.0.0, {value} must no longer be quoted.
@warning
    Environment variable only support string and numeric values.
@warning
    The command flavor (and the next one that takes a {assignment-string})
    only support expressions that aren't modified by function context. I.e.
    variables must be explictly global, buffer-, windows-, or tab-local.  |s:|
    variables won't give the correct result, nor expressions like
    `expand('<sfile>')`.

{hide-or-overwrite} parameter makes sense only for |p:variables| when there is
a hierarchy of projects. Its possible values are `"overwrite"` or `"hide"`. By
default (empty), `"hide"` is assumed.

This permits to chose between:
- hiding any preexisting occurence(s) of `p:foobar` in parent projects by
  defining the new `p:foobar` variable at current (leaf) project scope ;
- and overwriting any preexisting occurence of `p:foobar` in parent projects
  with a new value -- if there was none, the `p:foobar` variable will be
  stored in the current (leaf) project.

In order to properly see how dictionaries are handled, refer to
`s:Test_best_varname_match()` from `tests/lh/project.vim`, and to
|lh#project#_best_varname_match()|.

lh#let#to({assignment-string})~
Flavour meant to be used internally by |:LetTo|

These function and command make sure the variable named {varname} exists and
values {value}.
The {varname} can be a |Dictionary| with all its fields.

Examples: >
    call lh#let#to('g:dummy_test1', 42)
    LetTo g:dummy_test1 42
    LetTo g:dummy_test1 = 42

    LetTo g:dummy_test1 = some#func(g:var+t:var) " OK
    LetTo g:dummy_test1 = s:(g:var+t:var)        " Error
    LetTo g:dummy_test1 = some#func(var)         " Error

    call lh#let#to('g:dummy_test2', {'a':1, 'b':{'c':5}})
    LetTo g:dummy_test2.un.deux {'a':1, 'b':{'c':5}})
    LetTo g:dummy_test2.un.deux = {'a':1, 'b':{'c':5}})

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                 *lh#let#unlet()*     *:Unlet*      {{{3
lh#let#unlet({varname})~
:Unlet {varname}~
@param[in] {varname} scoped named of a variable (|w:|, |b:|, |p:|, |t:|, |g:|)
@note `p:`Environment variables are supported as well. But vanilla environment
variables aren't.
@note |command-completion| is supported on {varname}.

These function and command make sure the variable named {varname} doesn't exists.
The {varname} can be a |Dictionary| with all its fields. It that case, only
the last field is removed.

Examples: >
    Unlet g:dummy_test1
    " or
    call lh#let#unlet('g:dummy_test1')

    Unlet g:dummy_test1.un.deux
    " or
    call lh#let#unlet('g:dummy_test2.un.deux')

------------------------------------------------------------------------------
PROJECT DEFINITIONS                                   *lhvl#project*    {{{2
@since Version 4.0.0

Vim support various means to define options.
 * First there are vim options that are used to tune how Vim behaves in various
   situations. They are set with |:set|. Some are global, other are local to
   buffers. In this later case we usually choose their value either on a
   filetype basis, or a project basis.
 * Then there are plugin options. Again, they can be |g:|lobal,
   |b:|uffer-local, or even |w:|indow or |t:|ab local. In lh-vim-lib I've been
   providing |lh#option#get()| to obtain in a simple call the most refined
   value of an option. In
   [|lh-dev|](http://github.com/LucHermitte/lh-dev#options-1), I've went a little
   bit further in order to support specialization for buffer and/or filetypes.

Given the objective to have options that are project specific, it's quite easy
to achieve it thanks to plugins like
[|local_vimrc|](https://github.com/LucHermitte/local_vimrc/) (or similar
techniques). With these plugins, we say a file belongs to a project when it's
located in a directory under the one where a `_vimrc_local` file resides.

In that `_vimrc_local` file, we define project-specific options as local
options with |:setlocal|, and |b:|uffer_local_options.

That works well I've said. Up to a point: a same option could be duplicated
hundred times: once in each buffer that belongs to a project. As long as we
don't want to change an option this is fine. But as soon as we want to change a
setting we have to change it in every opened buffer belonging to the project,
which is tedious to do correctly.

How often does this need arise? Much to often IMO. In
[|BuildToolsWrappers|](https://github.com/LucHermitte/BuildToolsWrappers/),
I've experimented the issue when I wanted to change the current compilation
directory (from _Debug_ to _Release_ for instance). This is just one option,
but it impacts CMake configuration directory, included directory list (for
`.h.in` files), build directory, etc.

Being able to toggle an option between several values, when this is a buffer
local option, quickly becomes a nightmare. This is because we don't have
`p:roject_options`.

Note, that's it's also possible to specify project settings with
[|editorconfig|](https://github.com/editorconfig/editorconfig-vim). The syntax
will be slightly different from the usual. See the related section in
doc/Project.md.

So? Let's have them then!

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                              *project-options*                {{{3
*g:lh#project.auto_detect*
Tells whether we should try to automatically detect whether a file belongs to
a project.
So far, we use |lh#project#root()| result as an indicator of belonging to a
project.

See also |g:lh#project.permissions|.

When set to 1, there is no need to explicitly define a project.

Default value is 0

*g:lh#project.auto_chdir*
Tells whether we should automatically change the local current working
directory for every files in projects to reflect the source paths associated
to their associated project *p:paths.sources*

So far, we use |lh#project#root()| result as default value for `p:paths.sources`.

Default value is 0

*g:lh#project.permissions*
Specifies whitelist, blacklist, asklist and sandboxlist of pathnames to be
used when trying to automagically find projects with |g:lh#project.auto_detect|.
Default values for:
- *g:lh#project.permissions.whitelist*   : []
- *g:lh#project.permissions.asklist*     : [$HOME] // unless found in another list
- *g:lh#project.permissions.blacklist*   : ['/']   // always forced!
- *g:lh#project.permissions.sandboxlist* : []

These lists are best handled with:
- *lh#project#permission_lists()* to obtain the current value
- *lh#project#munge()* to add a new path to a list
- *lh#project#filter_list()* to filter paths in a list
Indeed, these functions make sure the `g:lh#project.permissions` variable has
been defined before doing any thing on it.

For instance, they can be overriden in the |.vimrc| with: >

    " Req: the following expects lh-vim-lib to have already been activated
    " by your plugin manager.
    "
    " $HOME/.vim/addons is where VAM stores the plugins it manages
    call lh#project#munge('whitelist', $HOME.'/.vim/addons')
    call lh#project#munge('whitelist', $HOME.'/workspace')
    call lh#project#munge('asklist',   $HOME.'/3rdparties')
    call lh#project#munge('blacklist', $HOME)
    call lh#project#munge('blacklist', '/')
    " Remove $HOME from asklist in case it was already there
    call lh#project#filter_list('asklist', 'v:val != $HOME')

See also |lh#path#new_permission_lists()|, which is used internally to manage
these lists.

*g:lh#project.root_patterns*
|List| of file names and of directory names. Whenever one is found from the
directory of the current |buffer,| we'll use its directory as a base for the
to deduce the project root directory.

By default the option is initialized with >
    LetIfUndef g:lh#project.root_patterns = ['.git/', '.svn/', '.hg/', '_darcs/', '.bzr/']

You can use filename patterns, of dirname patterns (ending with a trailing
slash). In both cases, see |file-searching| for the syntax.


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *p:* *project-variable*          {{{3
Can be a project specific variable:
- a vim |option|
- an |environment| variable (which will be set on the fly by functions like
  |lh#os#system()|, or |lh#asynch#queue()|)
- any variable.

These variables can be set with:
- |:LetTo|
- |:LetIfUndef|

Their value is meant to be retrived with:
- |lh#option#get()| (and |lh#dev#option#get()| eventually) in variable cases
- or use on the fly in case of |environment| variables

TODO: add word about special handling of |options|

But first, we need to define a project (see |:Project--define|, and
|lh#project#define()|).

*P:*
|:LetIfUndef|, |:LetTo| and co also support the special `P:` scope. In their
context it means: try to set the related |p:| variable, if the current buffer
is under no project, then set instead a |b:| variable with the same name.


                                                *reserved-p:variable*
Reserved p:variables~
Some `p:variables` are reserved:
- *(bpg):paths.sources* is the root directory of a project.
- *(bpg):project_sources_dir* configuration variable that help detecting
  |(bpg):paths.sources|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *:Project*                       {{{3
:Project --help~
Displays this help.

:Project --usage~
Shows the various ways to use this command.

                                                    *:Project--define*
:Project --define {prj-name}~
Defines a new project named {prj-name} -- see |lhvl-project_name|.

If a project with that name already exists, the current buffer will be
automatically registered to this project.
Otherwise, a project named {prj-name} will be defined. If the current buffer
belonged to another project, the new project will automatically inherit from
the old one. See |lhvl#project-inherit|.

@post there exists a project named {prj-name}
@post the current buffer belong to a project named {prj-name}
@seealso |lh#project#new()| and |lh#project#define()|.

                                                    *:Project--list*
:Project --list~
Lists all known projects.
An project without an explicit name will be provided one automatically.
See |lhvl-project_name|.

                                                    *:Project--which*
:Project --which~
Lists all projects to which the current buffer belongs.

                                                    *:Project-:ls*
:Project [{prj-name}] :ls~
Displays the buffers associated to the project {prj-name}, or the current
project (is none was specified) in the same way as builtin |:ls| command.

                                                    *:Project-:cd*
:Project [{prj-name}] :cd {dirname}~
Changes the project current directory with |:lcd|.
Applies the change to all windows where buffers from the project are
displayed.
@pre {dirname} must be a valid directory
@pre a project (named {prj-name} if specified) must exist.
@post `p:paths.sources` equals {dirname}

If {dirname} equals `'!'`, the current directory in the current buffer is
restored to |(bpg):paths.sources|. This is meant as a workaround to a pending bug
where current paths are changed behing our back.

                                                    *:Project-:echo*
:Project [{prj-name}] :echo {varname}~
Echoes the value of the |p:|variable {varname} associated to specified
project, or to the current project otherwise.

                                                    *:Project-:let*
:Project [{prj-name}] :let {varname} = {value}~
Sets the value of the |p:|variable {varname} associated to specified
project, or to the current project otherwise, to {value}

                                                    *:Project-:doonce*
:Project [{prj-name}] :doonce {cmd}~
Executes {cmd} in the first window found that is associated to specified
(or current) project. If no buffer from the project is opened in a window, we
try to open one (which'll be automatically discarded).
@pre the project shall have listed buffers.

The best way to execute |:make| on a project is with this subcommand. This way,
it makes sure all variables related to the project are correctly set when
compiling. >

    :Project ProjectName :doonce make %<

Note that `:Project :doonce command` is strictly equivalent to `:command` and
doesn't really make any sense.

                                                    *:Project-:windo*
:Project [{prj-name}] :windo {cmd}~
Executes {cmd} in all windows associated to the specified (or current)
project. This is similar to |:windo|, except the windows used are filtered
beforehand.
@pre the project shall have listed buffers.

                                                    *:Project-:bufdo*
:Project [{prj-name}] :bufdo {cmd}~
Executes {cmd} in all buffers associated to the specified (or current)
project. A temporary window is opened for the occasion (contrary to
|:bufdo| which uses the current window) .
@pre the project shall have listed buffers.

                                                    *:Project-:bnext*
:Project [{prj-name}] :bnext[!] [--hidden]~
|:bnext|-like command restricted to buffers from the specified/current
project.
Go to the next buffer in the buffer list of the specified (or current)
project.
See |:buffer-!| for [!]
`--hidden` option will restrict the iteration to |hidden-buffer|s.

                                                    *:Project-:bprevious*
:Project [{prj-name}] :bprevious[!] [--hidden]~
|:bprevious|-like command restricted to buffers from the specified/current
project.
Go to the previous buffer in the buffer list of the specified (or current)
project.
See |:buffer-!| for [!]
`--hidden` option will restrict the iteration to |hidden-buffer|s.

                                                    *:Project-:bdelete*
                                                    *:Project-:bwipeout*
:Project {prj-name} :bd[elete]~
:Project {prj-name} :bw[ipeout]~
Executes |:bdelete| (/resp. |:bwipeout|) to all buffers associated to the
specified project.
Also, remove the project (as its all sub-projects) from the list of all known
project.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#new()*               {{{3
lh#project#new(options)~
@internal
Prefer |:Project--define| or |lh#project#define()|.

@post A project without an explicit name will be provided one automatically.

Reserved fields:
- `"name"`      <- Project name   *lhvl-project_name*
- `"parents"`   <- List of parent projects
- `"buffers"`   <- buffer ids that belongs to the project
- `"variables"` <- where p:foobar will be stored
- `"options"`   <- where altered vim options will be stored
- `"env"`       <- where $ENV variables will be stored

Avoid depending on these fields.

and functions:
- _`inherit()`         <- registers a new parent project (internal)
- `_register_buffer()` <- registers a buffer to a project (internal)
- `_remove_buffer()`   <- removes a buffers from "`buffer`" list
- `_update_option()`   <- propagates an option value in all project buffers ; don't change current buffer
- `_use_options()`     <- propagates all options to all project buffers
- `apply()`            <- applies |Funcref| to all project buffers
- `children()`         <- returns list of children projects
- `depth()`            <- returns the maximum project hierarchy depth
- `environment()`      <- aggregates all $ENV defined at current and parent levels
- `exists()`           <- tells whether a variable is defined at current/parent level
- `find_holder()`      <- returns |dict| that holds a given var/opt/env
- `find_holder_name()` <- returns public fullname to a project var/opt/env
- `get()`              <- returns the value of a var/opt/env at project/parent level
- `get_names()`        <- returns the |list| of all variables and options stored at this project level
- `map()`              <- returns `map(copy(self.buffers), a:action)`
- `set()`              <- sets a new value to a var/opt/env, at project level
- `update()`           <- updates the value of a var/opt/new, at the project level that holds the data

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#define()*            {{{3
lh#project#define(s:, options [, varname])~
@post the current buffer is registered to the project returned.
Unless the current buffer is not eligible to belong to a project, in which
case |lh#option#unset()| is returned. To be eligible to a project a buffer
shall neither be distant, nor be a scratch buffer, nor be a quickfix buffer.

While |:Project--define| permit to create new projects quite easily, it
doesn't return a variable to the new project.

Instead we could use `lh#project#define()` to store the new project variable
into `s:project`, or `s:{varname}` automatically. If a project already exists
in that variable, it get returned.

Unlike |:Project--define|, `lh#project#define()` doesn't require a name. A
default one will be provided.

In the case different independent project configurations may co-exist in a
`_vimrc_local.vim` file, you may need to have several branches, and call
`lh#project#define()` with a third parameter to distinguish the projects. This
will permit to store project information in a variable with a name which is not
from `s:project`.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#crt()*               {{{3
lh#project#crt()~
@return the current project.
@return In case there is no project associated to the current buffer,
|lh#option#unset()| will be returned.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#_get()*              {{{3
lh#project#_get(varname)~
@return a variable named {varname} under the current project, or its parents.
@return |lh#option#unset()| if the current buffer doesn't belong to a project
or if there is such project variable.

@internal Used by |lh#option#get()|

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#crt_bufvar_name()*   {{{3
lh#project#crt_bufvar_name()~
@return the name of the current project variable

In case there is no project associated to the current buffer,
an exception will be thrown.

This will most likely return `b:crt_project`, the exact name depends on
*g:lh#project#varname* global which can be overridden in your |.vimrc|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#_crt_var_name()*     {{{3
lh#project#_crt_var_name(p:var)~
This internal function is use by `lh#let#*` functions.
It'll return:
- A |dictionary| if {var} starts with `&` or `$`:
  - `"realname"` =
    - `lh#project#crt_bufvar_name().env.{var}` for environment variables
    - `lh#project#crt_bufvar_name().options.{var}` for vim |option|s
  - `"name"` = {var} (without the `"p:"`part)
  - `"project"` a reference to the associated project variable
- The |string| `lh#project#crt_bufvar_name().variables.{var}` otherwise.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                                *lh#project#menu*                {{{3
Helpers functions for defining menu entries in `&Project`~
All project releated entires will go in the menu `&Project` with a priority of
50. This default entry point can be overriden in your |.vimrc| (and nowhere
else) with something like: >

    let g:lh#project.menu = { 'name': '&MyProject.', 'priority': '42.' }

Don't forget the dot at the end.

From here, |lhvl#menu| functions have been overriden to automatically define
new menu entries along with other project related topics.

*lh#project#menu#def_toggle_item()*  specializes |lh#menu#def_toggle_item()|
*lh#project#menu#make()*             specializes |lh#menu#make()|
*lh#project#menu#remove()*           specializes |lh#menu#remove()|

------------------------------------------------------------------------------
DESIGN BY CONTRACT FUNCTIONS                          *lhvl#DbC*    {{{2
@since Version 4.0.0
This set of functions introduces DbC helpers. There are here to help plugin
developers to detect and eradicate vim-scripting programming errors.
When an assertion fails, we cannot expect the script to go on correctly. There
IS an error in its logic. We cannot expect anything good after that. That's
where `lh#assert#*()` functions differs from Vim |test-functions| and my
vim-|UT.txt| plugin: these other functions aim at providing tools to write
unit tests.

As with Vim |test-functions|, all errors will be traced in an internal
variable that can be:
- fetched with *lh#assert#errors()*
- and cleared with *lh#assert#clear()*

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   *dbc-mode*   *lh#assert#mode()*     {{{3
lh#assert#mode([mode])~
As with C++20+ DbC proposal, end-user can select the assertion mode he wants
to run with. The default behaviour will remind things to Windows users: a
|confirm| box will ask whether we want to |dbc-ignore|, |dbc-stop|, or enter
in |dcb-debug|.

- *dbc-ignore* -- we'll try to go on. But don't (you, the end-user) expect
  miracles, the plugin will certainly fail miserably in a few seconds.
  Pray.
  Note that unlike C and C++, the tests cannot be avoided with
  |lh#assert#equal()| & co, but it could be short-circuited with
  |lh#assert#value()| and |lh#assert#type()| tests.
- *dbc-stop* -- we'll |:throw| an exception with as much context as possible.
- *bdc-debug* is a tricky one. This mode is aimed at plugin writers.
  |:debug| mode will be entered. Don't expect to be able to run anything
  useful that isn't |>bt|, |>up|, |>down| or |:echo|.
  - At the current level, the `cb` variable contains the call stack in a format
  compatible with |setqflist()| and |setloclist()|. This means you can fill
  them with either >
    :call setqflist(cb) " or
    :call setloclist(0, cb)
<  - At the next level (run `:up` once), the `bt` variable contains unfiltered
information about the backtrace. You should not need it.
  - In order to exist this debugging mode, you have the choice between |>cont|,
  |>next|, |>interrupt| or |>quit| (beware, `>q` will not trigger the
  execution of |:finally| blocks.)
- *dbc-stacktrace* -- can be accessed only from the default (empty) mode:
  it'll display the stacktrace associated to the current assertion failure in
  the quickfix window, and then ask whether we which to `'ignore'`, `'stop'`
  or `'debug'`.

Executing `lh#assert#mode()` with either `'ignore'`, `'stop'` or `'debug'`
will force the assertion mode globally. To go back to the |confirm| box, call
the function with an empty string.
Calling the function with no argument will permit to know which mode is the
current one.
You may also use `:Toggle PluginAssertionmode [{value}]` to change its value
with |lhvl-:Toggle|.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                *assertion-list*  *lh#assert#X()*   {{{3
Let me know if you really need to know what is tested...
In doubt, remember that I've mimicked the interfaces from Vim |test-functions|.

lh#assert#true({actual} [, {msg}])                     *lh#assert#true()*
lh#assert#false({actual} [, {msg}])                    *lh#assert#false()*
lh#assert#equal({expected}, {actual} [, {msg}])        *lh#assert#equal()*
lh#assert#not_equal({expected}, {actual}  [, {msg}])   *lh#assert#not_equal()*
lh#assert_is({expected}, {actual} [, {msg}])           *lh#assert#is()*
lh#assert_is_not({expected}, {actual} [, {msg}])       *lh#assert#is_not()*
lh#assert#match({pattern}, {actual} [, {msg}])         *lh#assert#match()*
lh#assert#empty({actual} [, {msg}])                    *lh#assert#empty()*
lh#assert#not_empty({actual} [, {msg}])                *lh#assert#not_empty()*

lh#assert#unexpected([, {msg}])                        *lh#assert#unexpected()*
    This one is new: it marks unexpected situations, without the need to call
    `lh#assert#true(0, msg)`

lh#assert#if({cond1}).then_expect({cond2} [, {msg}])   *lh#assert#if().then_expect()*
    This one is new: it asserts {cond1} => {cond2},
    i.e. it asserts that {cond2} is True when {cond1} is True.
    `lh#assert#if(context_applies).then_expect(stuff)`



lh#assert#value({actual})....                          *lh#assert#value()*
    Just another syntax to do the same thing. Choose what suits you best.
    Notes:
    - these functions return {actual}, while `not()` inverse the following tests.
    - these functions are much faster than the other ones when the current
      |dbc-mode| is |dbc-ignore|.
    e.g. >
    call lh#assert#value({'a': 1}).has_key('a')
    call lh#assert#value({'a': 1}).not().has_key('b')

lh#assert#value({actual}).equal({ref}[, {msg}])                 *lh#assert#value().equal()*
lh#assert#value({actual}).differ({ref}[, {msg}])                *lh#assert#value().differ()*
lh#assert#value({actual}).is_lt({ref}[, {msg}])                 *lh#assert#value().is_lt()*
lh#assert#value({actual}).is_le({ref}[, {msg}])                 *lh#assert#value().is_le()*
lh#assert#value({actual}).is_gt({ref}[, {msg}])                 *lh#assert#value().is_gt()*
lh#assert#value({actual}).is_ge({ref}[, {msg}])                 *lh#assert#value().is_ge()*
lh#assert#value({actual}).empty([, {msg}])                      *lh#assert#value().empty()*
lh#assert#value({actual}).has_key({key}[, {msg}])               *lh#assert#value().has_key()*
lh#assert#value({actual}).match({pattern}[, {msg}])             *lh#assert#value().match()*
lh#assert#value({actual}).not([, {msg}])                        *lh#assert#value().not()*

lh#assert#value({actual}).is_set([{msg}])                       *lh#assert#value().is_set()*
lh#assert#value({actual}).is_unset([{msg}])                     *lh#assert#value().is_unset()*
    Relates to |lh#option#is_set()| and |lh#option#is_unset()|

lh#assert#value({actual}).get({index}|{key} [, {msg}])          *lh#assert#value().get()*
    Asserts first that {actual} is a |List| or a |Dictionary|.
    Then asserts it has an element at the given {index}|{key}.
    Finally returns an altered assertion object on which anything could be
    asserted, e.g.: >
    call lh#assert#value({'d:': 42}).get('d').eq(42)

lh#assert#value({actual}).verifies({func}, {arglist} [, {msg}]) *lh#assert#value().verifies()*
    Lazily checks anything.
    {func} and {arglist} are the exact same parameters as the ones used by
    |call()|. There is little difference tough, if {actual} is a |dictionary|
    with a {func} entry, then the predicate being asserted will be
    `{actual}.{func}({args})` instead of `{func}([{actual}]+{args})`.

    Unlike |lh#assert#true()|, this flavour doesn't evaluate {func} in
    |dbc-ignore| mode.

lh#assert#type({actual})....                           *lh#assert#type()*
    This time the assertions are done on the type of the expression.

lh#assert#type({actual}).is({expected} [, {msg}])               *lh#assert#type().is()*
lh#assert#type({actual}).belongs_to({expected}...)              *lh#assert#type().belongs_to()*
    They are very similar to |lh#assert#value()| tests, but on types.
    e.g. >
    call lh#assert#type([1,2]).is([])
    call lh#assert#type([1,2]).belongs_to([], {}, '')

                                                                     }}}1
==============================================================================
 (c) Luc Hermitte, 2001-2020 <http://github.com/LucHermitte/lh-vim-lib>, CC by SA 3.0 {{{1
 VIM: let b:VS_language = 'american'
 vim:ts=8:sw=4:tw=80:fo=tcq2:ft=help:
 vim600:fdm=marker:
